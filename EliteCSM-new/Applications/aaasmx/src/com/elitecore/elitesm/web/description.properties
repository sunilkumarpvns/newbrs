authpolicy.name=This parameter specifies the name of an Authentication Service Policy.

authpolicy.ruleset=This parameter facilitates you in configuring a check expression which will be applied on the incoming authentication request.<br><br>\ If this condition is successfully satisfied by the received authentication request, then this policy will be selected for being applied on the received request.

authpolicy.reqmod=This parameter enables you to select the request type, for this policy. <br><br>\
<b>Authenticate Only</b> </br></br> \
f the selected request type is <b>Authenticate Only</b>,  then authentication process will always be done for the request on which this policy is being applied. <br><br>\
<b>Authenticate and Authorize</b></br></br> \
If you have selected <b>Authenticate and Authorize</b>, then authentication and authorization both operations will be performed for the received request packet. <br><br>\
For Example: - Suppose an Authorize-Only request is received by EliteAAA and this request qualifies for certain auth service policy application, wherein request mode is selected as <b>Authenticate Only</b>. In that scenario, only authentication process will take place.<br><br>\
 
authpolicy.resbehavior=Default Response Behavior

authpolicy.hotlinepolicy=Hotline Policy

authpolicy.validatepacket=This parameter specifies whether RFC specific validation is to be enabled or not.<br><br>\
If this parameter is set to &quot;True&quot;, then RFC specific validation will be enabled.<br><br>\
If this set to &quot;False&quot;, then RFC specific validation will not be enabled.


authpolicy.supportedauthmethods=This parameter specifies which authentication method is used to authenticate the users. <br><br>\
 <b>Possible values :</b> <br><br>\
 PAP </br> CHAP </br> EAP </br> Http Digest </br> Proxy

authpolicy.usridentity=Specify the attribute to be used as user-identity.<br>\
Multiple attributes can also be used as user-identity with the use of & and | operators.<br>\
Eg:-- 0:1=* | 0:4=* <br>\
0:1=* & 0:4=192.168.5.65


authpolicy.case=The &quot;Select Case&quot; parameter is used to convert the user identity received in the authentication request packet, to either lower case, upper case or it will keep it as it is.<br><br>\
<b>Possible values:</b> <br><br>\
No Change </br> Lower Case </br> Upper Case <br><br>\
The value configured here will be as per the case in which the user identity exists in the database, i.e. if the user identity attribute is stored in lower case then <b>lower case</b> should be configured in this parameter. <br><br>\
If this parameter is configured as &quot;Lower Case&quot; and the user identity received in the request packet is in &quot;Upper Case&quot;, then this request will be dropped, as the system will not be able to find the user profile, due to case mismatch.

authpolicy.useridentity = This parameter has multiple sub-parameter configurations, as described below  :-- <br><br><br>\
<b>Strip user identity</b> <br><br>\
     ->	If u select <b>Strip user identity</b> then the value in the user-identity will be stripped.<br><br>\
   --------------------------------------------------------------------------------------------------<br><br>\
     <b>Separator</b> <br><br>\
     ->	Separator attribute requires being configured if the <b>Strip User Identity</b> parameter is selected. Either prefix or suffix of the username received in the authentication request, as per the configuration in the Realm Pattern, will be stripped and then the authentication process will occur. The prefix and suffix are considered based on the separator that you specify in the <b>Separator</b> parameter.<br><br><br>\
     Example: If <b>Strip User Identity</b> is selected, Separator is configured as <b>@</b> and <b>Realm Pattern</b> is selected as <b>suffix</b>, then from the username abc@elitecore.com, received in the request packet, the value elitecore.com will be stripped off and user will be authenticated based on <b>abc</b> username.<br><br><br>\
     --------------------------------------------------------------------------------------------------<br><br>\
     <b>Trim User Identity</b><br><br>\
     ->	If Trim User Identity parameters is selected, then the User Identity received in the request packet will be trimmed i.e. if any space is found before or after the user identity, then that space will be removed. <br><br>\
      --------------------------------------------------------------------------------------------------<br><br>\
      <b>Trim User Password</b><br><br>\
     ->	If Trim User Password parameters is selected, then the User Password received in the request packet will be trimmed i.e. if any space is found before or after the user Password, then that space will be removed. <br><br>\
    
authpolicy.userident=This parameter is used to configure the attribute based on which the user, for which authentication is to be performed, is identified. Out of all the user profiles stored in the database/file, the Authentication Service has to identify the user for which the Authentication Request is received. It does this with the help of the attribute id set in <b>User Identity Attribute</b> parameter of Authentication Service.<br>\
You can configure multiple attributes in this field, for profile identification. You can also configure nested attributes and Vendor Specific Attributes in this field. For multiple attribute configuration, EliteRadius will lookup for attributes in sequence. If an attribute is found in the request packet (as per the sequence), then it will ignore rest configured attributes.

authpolicy.rejectoncheck=On the basis of this parameter the system decides whether the authentication request should be rejected or forwarded for further processing, if the Attribute Id, configured in the check item of the service policy, is not found in the request packet. <br>\

authpolicy.rejectonreject=On the basis of this parameter the system decides whether the authentication request should be rejected or forwarded for further processing, if the Attribute Id, configured in the reject item of the service policy, is not found in the request packet.<br>\

authpolicy.actionpolicy=Policies are configured in the user profile. Now it is possible that inspite of configuring the policy for the user, it is not found due to caching issues. In such a scenario, this parameter comes into picture.<br><br>\
-> If you have the set this parameter as Accept</b>, then the EliteAAA server continues processing the request and if you have set the parameter as <b>Reject</b>, then the request will be rejected.

authpolicy.eapconfig=This parameter facilitates in configuring the EAP configuration that is to be referred to authenticate the users. <br><br>\
This parameter is applicable only if EAP is enabled in Supported Authentication Method. <br>\<br>\
The access path for creating EAP configuration is as below:<br>\<br>\
<b>Servers -> EAP config -> create EAP Config</b> 

authpolicy.digestconfig=This parameter facilitates in configuring the Digest configuration that is to be referred to authenticate the users. <br><br>\
This parameter is applicable only if Digest Authentication is enabled.  <br>\<br>\The access path for creating Digest configuration is as below: <br>\<br>\<b>Servers -> Digest Config -> create Digest Config</b>

authpolicy.cui=&quot;CUI&quot; is an abbreviation for <b>Change Of Authorization</b>. It specifies an alias for the subscriber identity, while routing RADIUS packet through the network. <br><br>\
This parameter is used only in the response packet with respect to CUI attribute received in the incoming access request packet.  <br>\<br>\
Depending on configuration, CUI can be Authenticated-Identity, value for GROUPNAME, or value given here (into CUI)

authpolicy.cuiattribute=This parameter specifies the cui attributes received in the Access request packet.

authpolicy.username=This parameter refers to the attribute based on which the user authentication is to be performed. Out of all the subscriber profiles stored in the authentication database/file, the Authentication Service has to identify the subscriber for which the Authentication Request is received. It does this with the help of the attribute-name set in &quot;User Name&quot; configuration of Authentication Service. <br>\<br>\
<b>Note:</b> Ensure that the attribute specified here is a part of the incoming request as well as the customer profile. Authentication process will not move forward unless it gets a customer having the value in his/her profile attribute matching with the value received in the request packet. <br>\<br>\Depending on configuration, User Name can be Authenticated-Username, value for GROUPNAME, or value given in the request packet.

authpolicy.usernameattribute=This parameter specifies the username attributes received in the Access request packet.

authpolicy.wimax=This parameter specifies whether Wimax services should be enabled or not.<br>\<br>\
 ->If this attribute is set to <b>TRUE</b>, then Wimax services will be enabled. <br>\->If set to <b>FALSE</b>, then any request received from a Wimax client will not be processed and an Access-Reject will be sent to that client.

authpolicy.gracepolicy=&quot;Grace Policy&quot; feature enables you to allow service access to the user, even after the user account is expired. <br>\<br>\
A grace-policy defines max number of days after account expiry, for service access will be allowed to the user. <br>\<br>\
Limited resource utilization can be configured into authorization policy for serving an account/request under grace period. <br><br>\
This parameter facilitates in configuring the name of the grace policy. <br>\<br>\

authpolicy.proxyserver=This parameter specifies the name of the proxy server that is to be used to transfer the received authentication requests. 

authpolicy.threegpp=This parameter specifies whether 3GPP service should be enabled or not.<br>\ <br>\ ->If this attribute is set to <b>TRUE</b>, then 3GPP processing will be supported. <br>\->If set to <b>FALSE</b>, then any request received from a 3GPP client will not be processed and an Access-Reject will be sent to that client.

authpolicy.sessionmanager=This parameter specifies the name of the Session Manager that is to be used to manage the user sessions. <br>\<br>\
The Access path for creating a Session Manager is:<br>\<br>\
<b>Servers -> Session Manager -> Create Session Manager</b>

authpolicy.sessiontimeout=This parameter specifies the number of minutes that a session can remain idle before the server terminates it automatically. <br><br>\
<b>Default value:</b>10 minutes. <br>\<br>\
<b>Note</b>: The minimum allowed value is <b>1</b> minute and the maximum is <b>1440</b> minutes.<br>\<br>\
->If this parameter is configured to 100 then the session will remain idle for 100 minutes before the server terminates automatically.

authpolicy.resattribute=EliteAAA after successfully processing a received request, responds to the client with the response attributes received from various modules viz. radius policy, plug-in, rating, etc. <br>\<br>\
Now using the &quot;Mandatory Response Attributes&quot; configuration, you can ensure that all the attributes, which are absolutely mandatory (to be sent in the response), are being sent in the response packet.<br><br>\
<b>Sample Value:</b> 0:8=192.168.4.77

authpolicy.drivergroup=This parameter specifies the driver group that is to be used to fetch the user profile from the AAA database on receipt of an authentication request. <br><br>\
----------------------------------------------------------------------------------------------------------------------<br><br>\
Here, W represents the no. of requests that should be served by the driver. <br><br>\
For Example, if we have configured W=1 for 1st driver and W=2 for 2nd driver, then the 1st authentication request will be served by the 1st driver and the next 2 requests will be served by the 2nd driver and so on.

authpolicy.secdrivergroup=This parameter specifies the driver group that is to be used as a fallback driver in case the drivers mentioned in the primary group fails to authenticate the user. 

authpolicy.preplugins=Specifies a list of pre-plugins.<br><br>\
If any of the Pre-Auth Plugin is configured, then the received authentication request will be forwarded to the plugin first.<br>\<br>\
After plugin application, the request can be forward for main processing, if it qualifies.

authpolicy.postplugins=Specifies a list of post-plugins.<br><br>\
If any of the Post-Auth-Plugin is configured, then the received authentication request is forwarded to the configured plugin, after the main authentication process is over.<br>\<br>\
After the plugin application, the response packet will be sent to the client, if it qualifies.

authpolicy.ippoolserver=Specifies a list of IP Pool Server ESI. <br><br>\
This parameter is applicable only if IP Pool communication is enabled. <br> <br>\
You can add multiple IP Pool Servers using the ADD button. 

authpolicy.esruleset= This parameter facilitates you in configuring a check expression which will be applied on the incoming authentication request for the ESI configured above to be selected.<br><br>\ If this condition is successfully satisfied by the received authentication request, then the above configured ESI server will be selected for further processing <br><br>\
-> Here you can configure multiple check attributes separated by various logical operators using the <b>Expression Builder</b> functionality. <br><br>\

servicepolicy.authpolicy.estranslationmapping=Translation Mapping
servicepolicy.authpolicy.esscript=Script

authpolicy.ratingclassattribute= Rating Class Attribute

authpolicy.sessiontimeout=&quot;Session Timeout&quot; specifies the number of minutes that a session can remain idle before the server terminates it automatically. <br><br>\
<b>Default value:</b> 10 minutes. <br><br>\
<b>Note:</b> The minimum allowed value is 1 minute and the maximum is 1440 minutes.

authpolicy.prepaidservers=Specifies the list of prepaid server ESI. <br> <br>\
This parameter is applicable only if Prepaid Communication is enabled. <br> <br>\
You can add multiple Prepaid Servers using the ADD button.

authpolicy.driver= This parameter specifies the driver that is to be used as a Fallback driver in case the driver mentioned in the primary group fails to serve the request or the primary driver id dead.


authpolicy.cgserver=Specifies the list of Charging Gateway server ESI. <br><br>\
This parameter is applicable only if Charging Gateway Communication is enabled. <br> <br>\
You can add multiple Charging Gateway Servers using the ADD button.

authpolicy.broadcastingserver=This parameter facilitates you in configuring the server to which the incoming Auth-Request is to be broadcasted.

authpolicy.anonymousidentity=Specifies the value of the user identity that will be used to fetch the profile and that profile will be considered as anonymous user.

servicepolicy.authpolicy.driverscript = Script

eappolicy.ruleset=This parameter facilitates you in configuring a check expression which will be applied on the incoming authentication request.<br><br>\ If this condition is successfully satisfied by the received authentication request, then this policy will be selected for being applied on the received request. <br><br>\
-> Here you can configure multiple check attributes separated by various logical operators using the <b>Expression Builder</b> functionality. <br><br>\
Example: 0:1=*@elitecore.com && (0:4=<b>192.168.4.240/<b> || 0:5=<b>2</b>)


cgpolicy.ruleset=This parameter facilitates you in configuring a check expression which will be applied on the incoming authentication request.<br><br>\ If this condition is successfully satisfied by the received authentication request, then this policy will be selected for being applied on the received request. <br><br>\
-> Here you can configure multiple check attributes separated by various logical operators using the <b>Expression Builder</b> functionality. <br><br>\
Example: 0:1=*@elitecore.com && (0:4=<b>192.168.4.240/<b> || 0:5=<b>2</b>)



concurrentpolicy.name=Specifies the name of the Concurrent login policy

concurrentpolicy.policytype=Specifies the policy type.<br>\
<b>Possible values:</b>  <br>\<br>\<b>Individual</b> : This policy will be applicable to an individual user, i.e. the max concurrent logins specified in this policy will be applicable to an individual user. <br>\<br>\<b>Group</b>: All the individuals, to which the same policy is applied, become part of a logical group. The &quot;Maximum Concurrent Login&quot; specified for the policy will be applicable to all the people to whom this policy is applied. For Example, if 3 is configured in &quot;Max Concurrent Login&quot; field and this policy is bound to 4 users then only 3 concurrent logins will be applied at a time irrespective of a user.

concurrentpolicy.maxlogin=<b>Limited:</b> Selecting &quot;Limited&quot; allows you to specify the number of maximum of concurrent sessions that can be allowed to an individual or group. <br>\<br>\<b>Unlimited:</b> Selecting &quot;Unlimited&quot; will facilitate you to allow unlimited concurrent logins to the user with whom this policy is being bound.

concurrentpolicy.mode=<b>General:</b> Selecting &quot;General&quot; applies the &quot;Maximum Concurrent Login&quot;, based on the number of current concurrent sessions for all the services available to the user.<br>\<br>\  <b>Service-wise:</b> Selecting &quot;Service-wise&quot; allows you to select the &quot;NAS Port-Type&quot; and the max logins allowed for a particular Nas-Port-Type.<br>\<br>\ Using this, you can bifurcate the count specified in the &quot;Maximum Concurrent Login&quot;, for each NAS-Port-Type/service available to the user.

concurrentpolicy.attribute=Attribute

concurrentpolicy.attributevalue=Attribute Value

concurrentpolicy.status=Status

concurrentpolicy.description=Description



acctpolicy.name=Specifies the name of the Accounting Service Policy.

acctpolicy.method=Specifies whether the acct request is to be processed locally or is to be proxy-forwarded. <br>\<br>\
->If this parameter is set to <b>Local</b>, then the Acct request is processed locally. <br><br>\
->If set to <b>Remote</b>, the Acct request is forwarded to certain configured proxy server.

acctpolicy.cuiattribute=This parameter specifies alias for the subscriber identity, while routing RADIUS packet through the network. This parameter is used only in the response packet with respect to CUI attribute received in the incoming access request packet.  <br>\<br>\Depending on configuration, CUI can be Authenticated-Identity, value for GROUPNAME, or value given here (into CUI)

acctpolicy.sessionmanager=This parameter specifies the name of the Session Manager instance which will aid in managing user sessions. <br><br>\
The Access Path for creating a Session manager is as below: <br>\
<b>Servers -> Session Manager -> Create Session Manager</b>

acctpolicy.resattribute=Specifies which attributes are to be sent in the Acct-Response Packet.

acctpolicy.driver=This parameter specifies the driver group that is to be referred on receipt of an accounting request. </br></br> Here, W represents the no. of requests that should be served by the driver. </br> For Example, if we have configured W=1 for 1st driver and W=2 for 2nd driver, then the 1st accounting request will be served by the 1st driver and the next 2 requests will be served by the 2nd driver and so on.      

acctpolicy.preplugin=Specifies a list of pre-plugins.<br>\<br>\If any of the Pre-Acct Plugin is configured, then the received accounting request will be forwarded to the plugin first.<br>\<br>\
After plugin application, the request can be forward for main processing, if it qualifies.

acctpolicy.postplugin=Specifies a list of post-plugins.<br>\<br>\If any of the Post-Acct-Plugin is configured, then the received accounting request is forwarded to the configured plugin, after the main authentication process is over.<br>\<br>\
After the plugin application, the response packet will be sent to the client, if it qualifies.

acctpolicy.ippoolservers=Specifies a list of IP Pool Server ESI. <br><br>\
This parameter is applicable only if IP Pool communication is enabled. <br><br>\
You can add multiple IP Pool Servers using the ADD button.

acctpolicy.prepaidservers=Specifies the list of prepaid server ESI. <br><br>\
This parameter is applicable only if Prepaid Communication is enabled. <br> <br>\
You can add multiple Prepaid Servers using the ADD button.

acctpolicy.cgservers=Specifies the list of Charging Gateway server ESI. <br><br>\
This parameter is applicable only if Charging Gateway Communication is enabled. <br><br>\
You can add multiple Charging Gateway Servers using the ADD button.

acctpolicy.adddrivers=Specifies a list of additional drivers that could be configured along with the main drivers configured in the accounting driver group.

acctpolicy.validatepacket=This parameter specifies whether RFC specific validation is to be enabled or not.<br><br>\
If this parameter is set to &quot;True&quot;, then RFC specific validation will be enabled.<br><br>\
If this set to &quot;False&quot;, then RFC specific validation will not be enabled.

acctpolicy.esruleset=This parameter facilitates you in configuring a check expression which will be applied on the incoming authentication request for the ESI configured above to be selected.<br><br>\ If this condition is successfully satisfied by the received authentication request, then the above configured ESI server will be selected for further processing <br><br>\
-> Here you can configure multiple check attributes separated by various logical operators using the <b>Expression Builder</b> functionality. <br><br>\

servicepolicy.acctpolicy.estranslationmapping=Translation Mapping
servicepolicy.acctpolicy.esscript=Script
servicepolicy.acctpolicy.driverscript = Script

dynaauthpolicy.name=Specifies the name of the Dyna Auth Service Policy. 

dynaauthpolicy.ruleset=This parameter facilitates you in configuring attribute-based rule; if this rule is successfully satisfied by the received dynauth request, then this policy will be selected for being applied on the received dynauth request.

dynaauthpolicy.resattribute=Specifies which attributes are to be sent along with the Dyna Auth Response Packet, if the process was successful.

dynaauthpolicy.validate=Specifies whether the Dyna Auth packet should be validated or not.<br>\ <br>\ ->If set to TRUE, the packet will be validated.<br>\ ->If set to FALSE, the packet will not be validated.

dynaauthpolicy.dbdatasource=Specifies the name of the data source that is to be used by the Dyna Auth Service.

dynaauthpolicy.table=Specifies the name of the Dyna Auth Table in the data source.

dynaauthpolicy.session=The &quot;Eligible Session&quot; parameter specifies the user session details which should be considered for being sent to the NAS by the EliteAAA Server. <br><br>\
<b>All</b><br><br>\
If All is selected in this parameter, then all the user session details will be considered. <br><br>\
<b>Recent</b><br><br>\
If Recent is selected, then only the recent login detail of the user will be considered. <br><br>\
<b>Oldest</b><br><br>\
If Oldest is selected, then the oldest login detail of the user will be considered. <br><br>\
<b>None</b><br><br>\
If None is considered, then none of the login details will be considered.

dynaauthpolicy.timestamp=Specifies a sequence of characters that denotes the time at which a particular event occurred.

dynauthpolicy.nasclients=This parameter specifies the NAS client to which a COA is to be sent. <br><br>\
An ESI instance for the NAS client must be created. Access Path for creating the ESI is as below:<br><br>\
External System Interface -> Extended RADIUS

servicepolicy.dynauthpolicy.translationmapping=Translation Mapping
servicepolicy.dynauthpolicy.script=Script 
servicepolicy.dynauthpolicy.dbfailureaction=DB Failure Action

dynauthpolicy.validatepacket = This parameter specifies whether RFC specific validation is to be enabled or not.<br><br>\
If this parameter is set to &quot;True&quot;, then RFC specific validation will be enabled.<br><br>\
If this set to &quot;False&quot;, then RFC specific validation will not be enabled.

dynauthpolicy.attributeids=Attribute Ids

dynauthpolicy.dbfield=DB Field

dynauthpolicy.defaultvalue=Default Value

dynauthpolicy.mandatory=Mandatory

dynauthpolicy.nas.ruleset=Ruleset
dynauthpolicy.nas.nas=NAS
dynauthpolicy.nas.translationmapping=Translation Mapping
dynauthpolicy.nas.script=Script

servicepolicy.eappolicy.resattrs=Response attributes
servicepolicy.eappolicy.script=Script
servicepolicy.eappolicy.anonymousidentity=Specifies the value of the user identity that will be used to fetch the profile and that profile will be considered as anonymous user.
servicepolicy.eappolicy.gracepolicy=This parameter is a drop-down with list of grace policy. <br><br>When customer account is expired and customer tries to login into network, Grace Policy is applied.<br><br> If Grace Policy is satisfied then customer can login into system. Grace policy can be defined in customer profile. But if business need a grace policy service wise, based on that Administrator can configure the grace policy in this parameter. 
servicepolicy.eappolicy.wimax=This parameter specifies whether Wimax services should be enabled or not.<br>\<br>\
 ->If this attribute is set to <b>TRUE</b>, then Wimax services will be enabled. <br>\->If set to <b>FALSE</b>, then any request received from a Wimax client will not be processed and an Access-Reject will be sent to that client.

servicepolicy.eappolicy.sessionmanagement=This parameter indicates whether the session manager will apply in service level or not <br><br>\ <b> Possible Parameters : </b> 1) True 2) False 

servicepolicy.eappolicy.diameterconcurrency=Diameter Concurrency

servicepolicy.eappolicy.additionaldiameterconcurrency=Additional Diameter Concurrency

servicepolicy.eappolicy.defaultsessiontimeout=Session Timeout

servicepolicy.eappolicy.cui=CUI

servicepolicy.eappolicy.advancedcuiexpression=Advanced CUI Expression

servicepolicy.eappolicy.cuiresposeattribute=CUI Response Attributes

servicepolicy.eappolicy.rfc4372cui=RFC-4372-CUI
servicepolicy.eappolicy.defaultauthresponsebehavior= Display a list with three values <br/><br/> 1)<b>REJECT (Current Behaviour) : </b> In this case a desired Result code can be configure. <br/>2)<b><b>DROP (No Response)</b></b> <br/>3) <b> HOTLINE(Hotline purpose) : </b> In this case a user can configure created hotline policy.   <br/><br/>In case when REJECT or HOTLINE is selected at that time a Default Response Behaviour Argument must have value.
servicepolicy.eappolicy.defaultresponsebehaviourargument= This parameter contains a value depends on <b>Default Response Behaviour</b> In case when Reject is configure then it must have a result code and when Hotline is configure then it must have a created hotline policy. 


servicepolicy.authpolicy.broadcastservers=Broadcast Server

servicepolicy.authpolicy.trueonattrnotfound=True On Attribute Not Found

servicepolicy.authpolicy.isresponsemandatory=Is Response Mandatory

eappolicy.name = This parameter specifies the name of the EAP Policy.

cgpolicy.name = This parameter specifies the name of the Charging Policy.

cgpolicy.drivergroup = Specifies a list of RM Charging Drivers.

servicepolicy.cgpolicy.script = Script

naspolicy.casesensitiveuid=The &quot;Select Case&quot; parameter is used to convert the user identity received in the authentication request packet, to either lower case, upper case or it will keep it as it is.<br><br>\
<b>Possible values:</b> <br><br>\
No Change </br> Lower Case </br> Upper Case <br><br>\
The value configured here will be as per the case in which the user identity exists in the database, i.e. if the user identity attribute is stored in lower case then <b>lower case</b> should be configured in this parameter. <br><br>\
If this parameter is configured as &quot;Lower Case&quot; and the user identity received in the request packet is in &quot;Upper Case&quot;, then this request will be dropped, as the system will not be able to find the user profile, due to case mismatch.

servicepolicy.naspolicy.script=Script

servicepolicy.naspolicy.sessionmanagement=This parameter indicates whether the session manager will apply in service level or not <br><br>\ <b> Possible Parameters : </b> 1) True 2) False 

servicepolicy.ccpolicy.sessionmanagement=This parameter indicates whether the session manager will apply in service level or not <br><br>\ <b> Possible Parameters : </b> 1) True 2) False 
servicepolicy.ccpolicy.defaultauthresponsebehavior= Display a list with three values <br/><br/> 1)<b>REJECT (Current Behaviour) : </b> In this case a desired Result code can be configure. <br/>2)<b>DROP (No Response)</b> <br/>3) <b> HOTLINE(Hotline purpose) : </b> In this case a user can configure created hotline policy.   <br/><br/>In case when REJECT or HOTLINE is selected at that time a Default Response Behaviour Argument must have value.
servicepolicy.ccpolicy.defaultresponsebehaviourargument= This parameter contains a value depends on <b>Default Response Behaviour</b> In case when Reject is configure then it must have a result code and when Hotline is configure then it must have a created hotline policy. 
# Alert Configuration

servermgr.alert.listenerName=Specifies the name of the Alert Listener.

servermgr.alert.listenerType=Specifies the type of the Alert Listener.<br><br>\
<b>Possible values:</b> <br>\
1.) Trap Listener <br>\
2.) File Listener <br>\
3.) Syslog Listener

#File Alert Listener

filealertlistener.filename=Specify the name of the log file that is to be used to store the alerts generated by the alert listener.  <br><br>\
<b>Possible Value</b>: elite-aaa-alert.log

filealertlistener.rolling=Specifies on what basis the log file must be rolled. <br><br>\
<b>Possible Values:</b> <br><br>\
1. Time-based <br>\
2. Size-based

filealertlistener.rollingunittime=The value of this parameter depends on the value of Rolling Type. <br><br>\
If Time-based rolling is selected in the rolling type, then the Rolling unit can be one of the following:<br>\ <br>\
1.	Daily <br>\
2.	Minute <br>\
3.	Hour 

filealertlistener.compressrollunit=Specifies whether log files generated are to be compressed or not

filealertlistener.repeatedmessagereduction=This parameter indicates whether Repeated Alert Messages should be reduced or not. <br><br>\ If this parameter is enabled, Repeated Alert messages will be reduced.<br><br>\ But, if this parameter is disabled, each & every Alert Message will be generated for the File Listener.

filealertlistener.maxrollunit=<b>Size-Based Rolling</b><br><br>\
For Size-Based Rolling, the Max Rolled Unit should not be more than 13 and if configured more than 13 then default 13 will be used. <br><br>\
---------------------------------------------------------------------------------------------<br><br>\
<b>Time-Based Rolling</b><br><br>\
For Time-Based Rolling, this parameter is not applicable.

filealertlistener.rollingunit=<b>Time-Based Rolling</b><br><br>\
If Time-Based rolling is selected, <br><br>\
<b>Possible Values:</b> <br>\3-Roll every minute <br>\
4-Roll every hour <br>\
5-Roll every Second.<br>\<br>\
<b>Size-Based Rolling</b><br><br>\
---------------------------------------------------------------------------------------------<br><br>\
If Size-Based rolling is selected, value will be in number of Kbs. 

filealertlistener.alertlist=Specifies the type of alerts that can be handled by the alert listener. <br><br>\
Ex: CDR storage problem, ServerUp, ServerDown, etc.

# Trap Listener

traplistener.name=Name

traplistener.server=This parameter specifies the service address of the server on which the SNMP service is running. <br><br>\
<b>Sample Value: </b>127.0.0.1:161 <br><br>\
The default port for the SNMP server is 161.

traplistener.version=Specifies the version of the Trap Server.<br><br>\
<b>Trap Version</b> determines the format of traps.Trap Version set is commonly applicable for all trap types set in the configuration.  <br><br>\
EliteAAA supports two version for SNMP traps: V1 and V2

traplistener.community=The string specified as a value in the Community parameter refers to the key that is shared between the EliteAAA Server and the MIB Browser.<br><br>\
Community string specified in EliteAAA Server i.e. in this attribute and MIB Browser should match, so as to enable communication between the two.

trapalertlistener.advtrap=Advance Trap

trapalertlistener.repeatedmessagereduction=This parameter indicates whether Repeated Alert Messages should be reduced or not. <br><br>\If this parameter is enabled, Repeated Alert messages will be reduced.<br><br>\ But, if this parameter is disabled, each & every Alert Message will be generated for the Trap Listener.

traplistener.list=SNMP Traps enable the SNMP agent to notify network administrator about important events taking place at EliteAAA Server end, by sending appropriate messages.</br></br> This section specifies the type of alerts that can be handled by the alert listener. <br>\<br>\ Ex: CDR storage problem, ServerUp, ServerDown, etc.

#Syslog Listener

syslogalertlistener.address=This parameter specifies the service address of the server on which the listener is running.

syslogalertlistener.facility=The facility specifies the subsystem that produced the message, i.e. all mail programs log with the mail facility if they log using a syslog listener. <br><br>\
Facility is one of the following keywords: auth, authpriv, cron, daemon, kern, lpr, mail and local0 to local7. 

syslogalertlistener.list=Specifies the type of alerts that can be handled by the alert listener. <br><br>\
Ex: CDR storage problem, ServerUp, ServerDown, etc.

syslogalertlistener.repeatedmessagereduction= This parameter indicates whether Repeated Alert Messages should be reduced or not.<br><br>\ If this parameter is enabled, Repeated Alert messages will be reduced.<br><br>\ But, if this parameter is disabled, each & every Alert Message will be generated for the Syslog Listener.




gracepolicy.name=&quot;Grace Policy&quot; feature enables you to allow service access to the user, even after the user account is expired. <br><br>\
A grace-policy defines max number of days after account expiry, for service access will be allowed to the user. <br><br>\
Limited resource utilization can be configured into authorization policy for serving an account/request under grace period.<br><br>\
This parameter specifies the name of the grace policy. <br><br>\

gracepolicy.value=This parameter is used to specify the number of days for which service access will be allowed after account expiry. <br><br>\
<b>Sample Value:</b> 5,10,15



createdriver.name=Specifies the name of the service driver.

createdriver.description=Description

createdriver.type=Specifies the type of the driver. <br>\<br>\
<b>Possible values:</b> <br>\
Auth service Driver<br>\
Acct service driver <br>\
<b>Sample Value:</b>DB Auth Driver



digestconf.name=Specifies the name of the Digest Configuration.

digestconf.description=Description

digestconf.realm=Specifies a string to be displayed to the users so they can know which username and password to use. <br><br>\
This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access to the network. <br> <br>\
Ex: abc.xyz@gotham.news.com.

digestconf.qop=This parameter specifies a quoted string of one or more tokens indicating the Quality of Protection values supported by the server. <br><br>\
Ex: The value <b>&quot;Auth&quot;</b> indicates Authentication. <br><br>\
<b>Default value: </b> Auth 

digestconf.opaque=Specifies a string of data, specified by the server, which should be returned by the client in the authorization header of subsequent requests with URIs in the same protection space. <br><br>\
It is recommended that this string must be a hexadecimal data.

digestconf.noncelength=Specifies the digest nonce length.

digestconf.digestnonce=Specifies a server specified data string which should be uniquely generated each time an unauthorized response is made.  <br><br>\
It is recommended that this string should be a hexadecimal data. <br><br>\
Since the string is passed in header lines as a quoted string, the double-quote character is not allowed. <br><br>\
<b>Note:</b>The contents of this parameter are implementation dependent.

digestconf.defaultalgo=&quot;Default Digest Algorithm&quot; refers to a string indicating a pair of algorithms used to produce the digest and a checksum. <br><br>\
If this is not present it is assumed to be MD5. <br><br>\
If the algorithm is not understood, the challenge should be ignored.

digestconf.draftsterman=Draft is a set of standards describing methods, behaviors, research or innovations applicable to the working of the internet and internet-connected systems. <br><br>\
Draft is similar to RFC. EliteRadius server supports RFCs for its working. In certain scenarios, you may want EliteAAA to also support standards as per Drafts. <br><br>\
When this parameter is set as &quot;True&quot;, the EliteAAA server will support Draft standards along with the RFC standards. <br><br>\
If configured as &quot;False&quot;, then the EliteAAA server will only support the RFC standards.




naspolicy.name=Specifies the name of the NAS Service Policy

naspolicy.ruleset=This parameter facilitates you in configuring an attribute rule, based on which this policy will be applied on the authentication request.

naspolicy.methods=It specifies which methods will be supported by this service policy.  <br>\<br>\Ex: if you configure PAP method in this field then, only the requests which contains password field will be accepted.

naspolicy.idattribute=Specifies the attribute to be used as user-identity. <br>\ <br>\Multiple attributes can be configured as user-identity with the use of comma operator.

naspolicy.updateuserid=This parameter has multiple sub-parameter configurations, as described below:- <br>\<br>\
-> If u select <b>Strip user identity</b> then the value in the user-identity will be stripped. <br>\<br>\
-> Separator attribute requires being configured if the <b>Strip User Identity</b> parameter is selected. <br>\<br>\
Either prefix or suffix of the username received in the authentication request, as per the configuration in the Realm Pattern, will be stripped and then the authentication process will occur. The prefix and suffix are considered based on the separator that you specify in the Separator parameter.

naspolicy.cui=This parameter specifies alias for the subscriber identity, while routing RADIUS packet through the network. This parameter is used only in the response packet with respect to CUI attribute received in the incoming access request packet. <br>\<br>\Depending on configuration, CUI can be Authenticated-Identity, value for GROUPNAME, or value given here (into CUI).

naspolicy.username=This parameter refers to the attribute based on which the user authentication is to be performed. Out of all the subscriber profiles stored in the authentication database/file, the Authentication Service has to identify the subscriber for which the Authentication Request is received. It does this with the help of the attribute-name set in &quot;User Name&quot; configuration of Authentication Service. <br>\ <br>\Note: Ensure that the attribute specified here is a part of the incoming request as well as the customer profile. Authentication process will not move forward unless it gets a customer having the value in his/her profile attribute matching with the value received in the request packet. <br>\<br>\Depending on configuration, User Name can be Authenticated-Username, value for GROUPNAME, or value given in the request packet.

naspolicy.resattribute=Specifies which attributes should be sent along with the Authentication Response Packet as mandatory attributes.

naspolicy.resattributeacct=Specifies which attributes should be sent along with the Accounting Packet as mandatory attributes.

naspolicy.drivers=Specifies a list of drivers that should be configured to manage different auth-requests.

naspolicy.preplugin=Specifies the name of the plug-in that is to be configured as pre-plugin.

naspolicy.postplugin=Specifies the name of the plug-in that is to be configured as post-plugin.

naspolicy.casesensitiveuid = Case Sentivity for User Identity

naspolicy.cuiresattrs= CUI Response Attributes

naspolicy.usernameresattrs=User Name Response Attributes

naspolicyacct.drivers=Specifies a list of drivers that should be configured to manage different acct-requests.

naspolicyacct.preplugin=Specifies the name of plug-in that is to be configured as pre-plugin.

naspolicyacct.postplugin=Specifies the name of the plug-in that is to be configured as post-plugin.

naspolicy.cuiattribute=This parameter specifies the cui attributes received along with the diameter reqeust packet.

naspolicy.usernameattribute=This parameter specifies the username attribute received along wiht the diameter request packet.

servicepolicy.naspolicy.cui=CUI

servicepolicy.naspolicy.advancedcuiexpression=Advanced CUI Expression

servicepolicy.naspolicy.cuiresposeattribute=CUI Response Attributes

servicepolicy.naspolicy.rfc4372cui=RFC-4372-CUI

servicepolicy.naspolicy.anonymousidentity=Specifies the value of the user identity that will be used to fetch the profile and that profile will be considered as anonymous user.

servicepolicy.naspolicy.gracepolicy=This parameter is a drop-down with list of grace policy. <br><br>When customer account is expired and customer tries to login into network, Grace Policy is applied.<br><br> If Grace Policy is satisfied then customer can login into system. Grace policy can be defined in customer profile. But if business need a grace policy service wise, based on that Administrator can configure the grace policy in this parameter. 

servicepolicy.naspolicy.wimax=This parameter specifies whether Wimax services should be enabled or not.<br>\<br>\
 ->If this attribute is set to <b>TRUE</b>, then Wimax services will be enabled. <br>\->If set to <b>FALSE</b>, then any request received from a Wimax client will not be processed and an Access-Reject will be sent to that client.

servicepolicy.naspolicy.diameterconcurrency=Diameter Concurrency

servicepolicy.naspolicy.additionaldiameterconcurrency=Additional Diameter Concurrency

servicepolicy.naspolicy.defaultsessiontimeout=Default Session Timeout
servicepolicy.naspolicy.defaultauthresponsebehavior= Display a list with three values <br/><br/> 1)<b>REJECT (Current Behaviour) : </b> In this case a desired Result code can be configure. <br/>2)<b><b>DROP (No Response)</b></b> <br/>3) <b> HOTLINE(Hotline purpose) : </b> In this case a user can configure created hotline policy.   <br/><br/>In case when REJECT or HOTLINE is selected at that time a Default Response Behaviour Argument must have value.
servicepolicy.naspolicy.defaultresponsebehaviourargument= This parameter contains a value depends on <b>Default Response Behaviour</b> In case when Reject is configure then it must have a result code and when Hotline is configure then it must have a created hotline policy. 


creditControlpolicy.name=This parameter specifies the name of a credit control policy.


#Session Manager 

sessionmanager.name=Specifies the name of the session manager instance which will aid in managing the user sessions.

sessionmanager.desc=Description

sessionmanager.servers=Specifies a list of Session management servers which will aid in managing the user sessions.

sessionmanager.translationmapping=Translation Mapping

sessionmanager.script=Script

sessionmanager.datasource=This parameter refers to the datasource name which will be used for inserting the session records and this datasource should also be configured in the &quot;Oracle Database Configuration&quot; of the Radius Server.

sessionmanager.tablename=This parameter refers to the Table Name which will be used for inserting the session records. </br></br> <b>Default value</b> : tblmconcurrentusers 

sessionmanager.enabled=This parameter decides that whether the batch processing of the accounting requests, by the concurrent login driver is enabled or not. </br></br> <b>Possible values</b> : &quot;True&quot; or &quot;False&quot; </br></br><b>Default value</b> : True

sessionmanager.size=This parameter refers to the number of requests which can be processed at a single go. <br><br>\
<b>Default value</b> : 1000 , i.e. only 1000 requests can be processed in single execution. <br><br>\
If there are more than 1000 requests, then they will processed next time, when the batch update scheduler runs. 

sessionmanager.updateinterval=The &quot;Update Interval&quot; parameter refers to the time interval after which the scheduler runs for each batch processing. <br><br>\
<b>Default Value: </b> 100 ms, i.e. the scheduler will run after every 100 ms.

sessionmanager.querytimeout=&quot;DB Query Timeout&quot; parameter is used for specifying the duration after which, if the database does not respond to a query, then the Server Manager should consider the &quot;query timeout&quot; event to have occurred. <br><br>\
This value is specified in terms of seconds. 

sessionmanager.autosessioncloser=The &quot;Auto Session Closure&quot;, if enabled, will release all the reserved IP Addresses which are not yet assigned. 

sessionmanager.sessiontimeout=This parameter specifies the time interval after which the session will get timeout. <br><br>\
Value in this parameter is specified in terms of &quot;Second&quot;.

sessionmanager.closebatchcount=&quot;Session Close Batch Count&quot; parameter determines the maximum number of sessions that can be closed by the Auto Session Closer process in a single execution. <br><br>\
For example, if &quot;Session Close Batch Count&quot; parameter is set to &quot;2&quot; and there are 8 sessions marked and also eligible for Closer. </br></br>The Auto Session Closer Process will consider only 2 sessions for Closer during a single execution. Next 2 sessions will be considered for Closer in the next execution of the process. 

sessionmanager.sessionthreadsleeptime=&quot;Session Thread Sleep Time&quot; parameter refers to the interval after which the auto session Closer process should execute and close the session(s) eligible for Closer. <br><br>\
Value in this parameter is specified in terms of  &quot;Miliseconds&quot;.

sessionmanager.statusduration=&quot;Status Duration&quot; parameter refers to the duration after which the Radius server should check whether the connectivity with the Target Server is available or not. <br><br>\
Value in this attribute is set in terms of &quot;Miliseconds&quot;. <br> <br>\
This means, if you set &quot;5&quot; as value of this parameter, then the Radius Server will check for the Target Server connectivity after every 5 ms.

sessionmanager.identityfield.fieldname=&quot;Field Name&quot; refers to the name of the column of the table specified in &quot;Table Name&quot; parameter, in which value (received in the request) of the Attribute ID selected in the same &quot;Attribute&quot; section should be saved.

sessionmanager.sequencename=Database based sequences are special (single-row) tables in the database created with a specific statement, e.g. CREATE SEQUENCE sequence name. <br><br>\
This implementation use database based sequences to assign IDs in auto-increment fields. <br><br>\
To address the sequences, each sequence has an unique sequence-name and hence this &quot;Sequence Name&quot; parameter is meant for call records. <br><br>\
<b>Default Value</b>: SEQ_TBLMCONCURRENTUSERS 

sessionmanager.starttimefield=&quot;Start Time Field&quot; refers to the name of the column of the table specified in &quot;Table Name&quot; parameter, in which value of the Start time of user session should be saved.

sessionmanager.lastupdatetimefield=&quot;Last Update Time Field&quot; parameter refers to the name of the column of the table specified in &quot;Table Name&quot; parameter, in which value of the Interim Update time of user session should be saved.

sessionmanager.sessionid.fieldname=&quot;Session ID Field Name&quot; parameter refers to the name of the column of the table specified in &quot;Table Name&quot; parameter, in which value of the Session ID of user session should be saved.

sessionmanager.field=Field

sessionmanager.dbfieldname=&quot;DB Field Name&quot; refers to the Attribute of the RADIUS server that you intend to save in the csv file that is to be generated after EliteAAA Server receives the Accounting Request. <br><br>\
&quot;DB Field Name&quot; could be the name of a RADIUS attribute, a Vendor-Specific attribute or even a custom attribute that is neither a RADIUS attribute nor a Vendor-Specific attribute, but you want the attribute to always be stored in the csv file.  <br><br>\
Click the &quot;Add&quot; button displayed beside Attribute List to add more Attribute section.

sessionmanager.referringentity=The &quot;Referring Attribute&quot; parameter refers to the column name which will be at the top of the column in which the correspondingly configured attribute, is stored in the .csv file. 

sessionmanager.searchcolumn.field=Search Column

sessionmanager.concurrencyidentityfield=Concurrency Identity Field

sessionmanager.datatype=&quot;Data Type&quot; attribute refers to the data type of the field which is to be mapped with the Database. <br><br>\
<b>Possible Values</b> :</br> String </br> Timestamp

sessionmanager.defaultvalue=It might so happen sometimes that a particular attribute, in the request packet is missing or its value is missing. <br><br>\
Under such circumstances, the EliteAAA Server puts the value that you have specified in the &quot;Default Value&quot; parameter in Attribute section of the attribute, under consideration.

sessionmanager.behaviour=There was support of session management in accounting service, but there is also need for session management in authentication service. <br><br>\
So for that provided configuration in Local Session manager as Behavior which are of two types: <br><br>\
1 - Acct - Acct mean classical way of Concurrency Check on Authentication Request, Session Creation on Accounting-Start and Session Deletion on Accounting Stop.  <br><br>\
2 - Auth - Auth mean newer way where Session will be created &frasl; updated on Authentication Request, Session will be updated on Accounting Start and Deletion will be Accounting Stop only. It is recommended for GSM and CDMA Mobile networks where single PDP from a device is only possible. 

sessionmanager.dboperationfailurebehaviour=Values for action on db error can be<br><br>\
1 - Ignore - It means session manager neither perform concurrency check nor rejecting customer on authentication request.In Accounting request, it means session manager will not generate failure event for unsuccessful operation in insert/update/delete operation.<br><br>\
2 - Reject - For Authentication request, it means session manger will reject the customer concurrency check as Database is not available. For Accounting request, it means session manager will drop the customer request as database is not available. <br><br>\
3 - Drop  - For Authentication and Accounting request,  it means session manager will drop the request if database is not available.<br><br>\

sessionmanager.sessionstopaction=Session Stop Action

sessionmanager.useridentity=This parameter specifies the user identity based on which the user session will be stored in the database.

sessionmanager.sessioncloseaction=This parameter specifies what action is to be taken after session closure. <br><br>\
Possible Values: <br><br>\
1 - Generate Disconnect <br><br>\
2 - Generate Stop <br><br>\
3 - Generate STop and Disconnect

sessionmanager.sessionoverrideaction=Session Override Action

sessionmanager.sessionoverridecolumn=Session Override Column


sessionmanager.groupnamefield=&quot;Group Name Field&quot; parameter refers to the name of the column of the table specified in &quot;Table Name&quot; parameter, in which value of the Group Name of user should be saved.

sessionmanager.servicetypefield=&quot;Service Type Field&quot; parameter refers to the name of the column of the table specified in &quot;Table Name&quot; parameter, in which value of the Service Type of user session should be saved.

sessionmanager.searchcolumn=Search Column

sessionmanager.asm.username=Name


#Radius Policy

radiuspolicy.expressions=Expressions

radiuspolicy.name=Specifies the name of Radius policy.

radiuspolicy.description=Description

radiuspolicy.status=Status

radiuspolicy.timebasecondition=Time Base Condition

radiuspolicy.checkitem=&quot;Check Item&quot; is an attribute that must be present in the request for allowing service access.  <br><br>\
NAS must send attributes that matches the attributes configured in Check Item; otherwise, EliteAAA rejects the user even if the user name and password are valid.<br><br>\
For example, following NAS IP Address is configured in the Check Item of the Radius Policy that is bound with the user profile, for which the request has been received:  <br><br>\
NAS_IP_ADDRESS = 192.168.1.35  <br><br>\
In this case, the user will be authenticated, only if the received request packet has the NAS_IP_ADDRESS that is configured in the Check Item. 

radiuspolicy.additem=&quot;Add Item&quot;
 
radiuspolicy.replyitem=&quot;Reply Item&quot; is an attribute that EliteAAA Server needs to return to the NAS after successful authentication.   <br><br>\
By including appropriate attributes in the Reply Item, a variety of connection policies can be applied to NAS to deliver appropriate services.  <br><br>\
For example:  </br>FRAMED_IP_ADDRESS = 203.88.135.206

radiuspolicy.rejectitem=&quot;Reject Item&quot; is an attribute that rejects the authentication request if the value of the attribute of the authentication request matches the value of that attribute configured in the Reject Item of the Radius Policy. <br><br>\
For example: If NAS_IP_ADDRESS = 192.168.6.11 is configured as reject item, then any request coming from this NAS IP address, will be rejected during authentication.



checkitem.id=Specifies the Attribute id that is to be configured as check item

checkitem.operator=Specifies the operator for check item. <br><br>\
<b>Possible values:</b><br><br>\
<b>Equal</b> <br>\
<b>Not Equal</b>

checkitem.value=Specifies the value of the attribute that is to be configured in check item



rejectitem.id=Specifies the Attribute id that is to be configured as reject item

rejectitem.operator=Specifies the operator for reject item. <br><br>\
<b>Possible values:</b><br><br>\
<b>Equal</b> <br>\
<b>Not Equal</b>

rejectitem.value=Specifies the value of the attribute that is to be configured in reject item



replyitem.reqres=Specifies whether this policy is to be applied on Request packet or Response packet.

replyitem.id=Specifies the Attribute id that is to be configured as Reply item

replyitem.operator=Specifies the operator for Reply item.<br><br>\
<b>Possible values:</b><br><br>\
<b>Equal</b> <br>\
<b>Not Equal</b> \
<b>Exist</b>

replyitem.value=Specifies the value of the attribute that is to be configured in Relply item

#Access Policy 

accesspolicy.name=This parameter specifies the name of the Access Policy to be created.

accesspolicy.defaultaccess = Specifies whether default access should be given to the user to which this policy is applied. <br><br>\
Possible Values: Allowed or Denied

accesspolicy.timeslaps= Specifies the duration for which this policy shuold be applied to a subscriber.

accesspolicy.description=Description

accesspolicy.status=Status

#Trusted Client Profile

clientprofile.name=Specifies the name of the client profile

clientprofile.type=Specifies the type of the client. <br><br>\
<b>Sample Value:</b> NAS

clientprofile.vendor=This parameter refers to the seller of the device being used as NAS.

clientprofile.dnslist=The &quot;DNS List&quot; parameter comes into picture in case of WIMAX and 3GPP2 flow. Comma separated values are supported in this field. <br><br>\
You can specify the IP addresses of more than one DNS servers in this parameter. <br><br>\
When a WIMAX request comes from the ASN Gateway, Radius server sends the response to the ASN Gateway along with the details of the DNS Servers, which the gateway can access.

clientprofile.useridentity=&quot;User Identity&quot; specifies the attribute to be used as user-identity. <br><br>\
Multiple attributes can also be used as user-identity with the use of comma (,) operator.

clientprofile.prepaidstd=Specifies standard (other than generic RADIUS standard) refered for attribute in prepaid communication.  <br><br>\
<b>Possible Values:</b> <br><br>\
<b>None</b>  is for generic radius standard  <br><br>\
<b>WIMAX_1_2</b> is for WiMAX NWG 1.2.

clientprofile.framedpool=Specifies comma(,) separated Framed pool names for the IP pool service.<br><br>\
The specified framed pool will be used if the framed pool is not found at the user level.

clientprofile.dhcpaddress=This parameter is used to store the IP Address of the DHCP Server, which will be referred by the client for IP Address allocation to the user. <br><br>\
Whenever any authentication request is received from the client, then the DHCP IP Address which is configured for this particular client will be sent back in the Access-Accept response packet.

clientprofile.haaddress=Specifies the ha ip address for this client <br><br>\
If any invalid value is configured in this field then 0.0.0.0 will be considered as default value.

clientprofile.multiclassattrib=Multiple Class Attribute

clientprofile.vendorlist=Specifies a list of supported vendors.

clientprofile.policy=Specifies the policy for the client. <br><br>\
You can configure Check Item, Reject Item, Reply Item and Add Item in this policy and then bind this newly created policy with the client in the Clients Configuration.

clientprofile.hotlinepolicy=Specifies the Hotline policy for the client. 

clientprofile.port=NAS Communication port to Receive COA and DM Packets.

clientprofile.coasupportedattribute=This parameter facilitates in configuring some supported COA attributes.<br>\<br>\Here, the restriction of attributes can be done based on 2 categories:<br>\ <b>Vendor-based</b> or <b>Attribute-based</b>. 
	
clientprofile.coaunsupportedattribute=This parameter facilitates in configuring some COA unsupported attributes which you want to exclude from the request packet.<br>\<br>\Here, the restriction of attributes can be done based on 2 categories:<br>\ <b>Vendor-based</b> or <b>Attribute-based</b>. 

clientprofile.dmsupportedattribute=This parameter facilitates in configuring some DM supported attributes.<br>\<br>\Here, the restriction of attributes can be done based on 2 categories:<br>\ <b>Vendor-based</b> or <b>Attribute-based</b>. 

clientprofile.dmunsupportedattribute=This parameter facilitates in configuring some DM unsupported attributes which you want to exclude from the request packet.<br>\<br>\Here, the restriction of attributes can be done based on 2 categories:<br>\ <b>Vendor-based</b> or <b>Attribute-based</b>. 

clientprofile.description=Description


dbdatasource.name=Specifies the datasource name by which the database is identified.
 
dbdatasource.url=It represents the connection string which the database driver should use to connect to the database.  <br><br>\
<b>Syntax:</b> jdbc:oracle:thin:@[IP Address]:[Port]:[SID]

dbdatasource.username=This parameter refers to the user name that should be used to establish connection to the database.

dbdatasource.password=This parameter refers to the password corresponding to the User Name that is used to connect to the database.

dbdatasource.timeout=&quot;Timeout&quot; refers to the duration for which EliteRadius server looks up an Oracle server to check if there is a record matching with an incoming authentication request.

dbdatasource.minconnection=Specifies the minimum number of connections that can exist, at any given point in time.

dbdatasource.maxconnection=Specifies the maximum number of connections that can exist, at any given point in time.

dbdatasource.statuscheckduration=&quot;Status Check Duration&quot; parameter refers to the duration after which the Open DB Driver should check for whether the connectivity with the Database is available or not. <br><br>\
Value in this attribute is set in terms of Minutes. This means, if you set 5 as value of this parameter, then the driver, will check LDAP database connectivity after every 5 minutes.



ldapdatasource.name=This parameter refers to the name of the LDAP datasource.

ldapdatasource.ip=This parameter refers to the IP Address of the machine on which the LDAP server is hosted. 

ldapdatasource.port=This parameter refers to the Port of the machine on which EliteRadius server listens to the authentication request.

ldapdatasource.timeout=&quot;Timeout&quot; refers to the duration for which EliteRadius server looks up an LDAP server to check if there is a record matching with an incoming authentication request.

ldapdatasource.sizelimit=This parameter refers to the size i.e. maximum no. of records to be returned as an output. <br>\<br>\ If 0 is configured in this field, then it indicates the size limit as unlimited 

ldapdatasource.ldapversion=LDAP Version 

ldapdatasource.administrator=This parameter contains the attributes related to the administrator to connect with the LDAP server.

ldapdatasource.pwd=Specifies the password of the LDAP server

ldapdatasource.dnprefix=<b>DN</b> is an abbreviation for Distinguished Name of the LDAP Server. <br><br>\
This parameter is used to specify the prefix of the LDAP Server&rsquo;s Distinguished Name that will be a part of the user identifier.

ldapdatasource.minpool=Specifies the minimum number of connections that can exist, at any given point in time.

ldapdatasource.maxpool=Specifies the maximum number of connections that can exist, at any given point in time.

ldapdatasource.basedn=This parameter is used to specify, which part of the LDAP directory hierarchy should be searched. <br>\ <br>\You can also specify multiple Search Base DN.

ldapdatasource.statuscheckduration=&quot;Status Check Duration&quot; parameter refers to the duration after which the Open DB Driver should check for whether the connectivity with the Database is available or not. <br>\<br>\Value in this attribute is set in terms of &quot;Minutes&quot;. This means, if you set 5 as value of this parameter, then the driver, will check LDAP database connectivity after every 5 minutes.




ldapdriver.ds=Specifies the name of the datasource that points to the LDAP database.

ldapdriver.expirydate=This parameter refers to the date format of the database attribute storing expiry date of the account, if any.

ldapdriver.pwdderypt=This parameter specifies the decrypt type that is to be used to decrypt the password received in an authentication request from the user. <br><br>\
<b>Sample Value:</b> 0 indicates password decryption to be None.  <br><br>\
It means the password will be received in plain text. 

ldapdriver.queryexectime=This parameter refers to the time duration for which the EliteAAA Server waits for the response from the LDAP Auth driver against the request sent to the later. <br><br>\
This value must be specified in terms of seconds.

ldapdriver.maxquerytimeoutcount=Maximum Query Timeout Count

ldapdriver.logicalname=This parameter refers to attribute received in the authentication request. 

ldapdriver.ldapattribute=When EliteAAA Server receives an authentication request, it matches the attributes therein, with the attributes in the customer profile in the LDAP database. <br><br>\
Take the User-Name attribute for instance. Now, the EliteAAA Server finds if a customer record with received Username exists in the LDAP database or not. <br>\
But how does it know that with which attribute in the LDAP database should it match the Username? This is where the Logical Name-LDAP Attribute mapping comes into picture. <br><br>\
Say, uid is the attribute of the LDAP database storing the Username. Thus, for mapping these attributes, you are required to specify the Logical Name, Username and LDAP Attribute uid. <br><br>\
Thus, on receiving an authentication request, the EliteAAA Server compares the Logical Name values in the request packet with the corresponding LDAP Attributes in the LDAP database. <br><br>\
Click the Add button corresponding to LDAP Field Mapping to add more Logical Name-LDAP Attribute pairs.

ldapauthdriver.searchfilter=Search Filter

ldapauthdriver.searchscope=Search Scope



driver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.

driver.valuemapping=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing.<br><br>\
Under such circumstances, the EliteAAA Server puts the value that is specified in the Default Value parameter in Attribute section of the attribute, under consideration.

#HTTP Auth Driver

httpdriver.url= &quot;Http URL&quot; is used to designate the URL of the remote server.

httpdriver.statuscheckduration=&quot;Status Check Duration&quot; parameter refers to the duration after which the Http Auth Driver should check for whether the connectivity with the Database is available or not. </br></br> <b>Default Value</b>: 5

httpdriver.querytimeout=&quot;Maximum Query Timeout Count&quot; parameter value refers to the maximum count of consecutive &quot;query timeout&quot; occurrence after which the Server Manager should mark the database as &quot;dead&quot;. <br><br>\
The database marked as &quot;dead&quot; will be marked &quot;live&quot; once it is up and running.<br><br>\
<b>Default Value</b>: 200

httpdriver.expdateformat=This parameter refers to the date format of the remote db Attribute storing the expiry date of the user account, if any.

httpdriver.logicalname=&quot;Logical Name&quot; refers to attribute received in an Http request for customer authentication. <br><br>\
The Response Parameter Index corresponding to Logical Name is specified in &quot;Response Parameter Index&quot; parameter. <br><br>\
Click the Add button corresponding to &quot;Http Response Mapping&quot; to add more &quot;Logical Name-Response Parameter Index&quot; pairs.

httpdriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.

httpdriver.valuemapping=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing.<br><br>\
Under such circumstances, the EliteAAA Server puts the value that is specified in the Default Value parameter in Attribute section of the attribute, under consideration.

httpdriver.responseParameterIndex=Response Parameter Index

webservicedriver.address=&quot;Service Address&quot; specifies the Service Address of the Aircel Web Service. </br></br>

webservicedriver.imsi=This parameter specifies the attribute in the AAA db that is to be used to store the IMSI received in the Web Service request.

webservicedriver.maxquerytimeoutcount=&quot;Maximum Query Timeout Count&quot; parameter value refers to the maximum count of consecutive &quot;query timeout&quot; occurrence after which the Server Manager should mark the database as &quot;dead&quot;. <br><br>\
The database marked as &quot;dead&quot; will be marked &quot;live&quot; once it is up and running.  <br><br>\
<b>Default Value</b>: 200

webservicedriver.statuscheckduration=&quot;Status Check Duration&quot; parameter refers to the duration after which the Aircel Web Service Auth Driver should check for whether the connectivity with the Database is available or not. <br><br>\
<b>Default Value</b>: 5

webservicedriver.logicalname=&quot;Logical Name&quot; refers to attribute received in the authentication request for customer authentication. <br><br>\
Web Service Key corresponding to Logical Name is specified in &quot;Web Service Method Key&quot; parameter.<br><br>\
Click the &quot;Add&quot; button corresponding to &quot;Web Service Key Mapping&quot; to add more &quot;Logical Name-Web Service Key&quot; pairs.

webservicedriver.webservicekey=When EliteAAA Server receives the customer profile from Aircel Web Service, it matches the attributes therein, with the attributes in the received auth request. <br><br>\
Take the &quot;MSISDN&quot; attribute for instance. Now, the EliteAAA Server finds if a customer record with received MSISDN exists in the customer profile received from Aircel web service or not. But how does it know that with which attribute in the received profile should it match the MSISDN? This is where the Logical Name-Web Service Key mapping comes into picture. Say, &quot;msisdn&quot; is the attribute of the web service storing the MSISDN.<br><br>\
Thus, for mapping these attributes, you are required to specify the Logical Name, &quot;MSISDN&quot; and Web Service Key &quot;msisdn&quot;. Thus, on receiving a Web Service request, the EliteAAA Server compares the Logical Name values in the request packet with the corresponding Web Service Key in the customer profile received from the Aircel web service.

webservicedriver.valuemapping=This parameter is used to specify the value mapping in case the attribute configured in the mapping expression have more than 1 value.

webservicedriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing.<br><br>\
Under such circumstances, the EliteAAA Server puts the value that is specified in the Default Value parameter in Attribute section of the attribute, under consideration.



#Map Gw Auth Driver

mapgw.localhostid=This parameter specifies the Host id of the AAA Auth G/w.

mapgw.localhostip=This parameter specifies the Host Ip of the AAA Auth G/w.

mapgw.localhostport=This parameter specifies the Host port of the AAA Auth G/w.

mapgw.remotehostid=Specifies the Host id of the Ulticom MAPAuth G/w.

mapgw.remotehostip=Specifies the Host Ip of the Ulticom MAPAuth G/w.

mapgw.remotehostport=Specifies the Host Port of the Ulticom MAPAuth G/w.

mapgwdriver.logicalname=&quot;Logical Name&quot; refers to attribute received in the 
-SIM authentication request for customer authentication. Profile Attribute corresponding to Logical Name is specified in &quot;Profile Field&quot; parameter.<br><br>\
Click the Add button corresponding to MAP Field Mapping to add more &quot;Logical Name-Profile Field&quot; pairs.

mapgwdriver.profileattribute=When EliteAAA Server receives the customer profile from Ulticom, it matches the attributes therein, with the attributes in the customers profile in the database.<br><br>\
Take the &quot;IMSI&quot; attribute for instance. Now, the EliteAAA Server finds if a customer record with received IMSI exists in the AAA database or not. But how does it know that with which attribute in the AAA database should it match the IMSI? This is where the Logical Name-Profile Field mapping comes into picture. Say, &quot;imsi&quot; is the attribute of the AAA database storing the IMSI. Thus, for mapping these attributes, you are required to specify the Logical Name, &quot;IMSI&quot; and Profile Attribute &quot;imsi&quot;.<br><br>\
Thus, on receiving an authentication request, the EliteAAA Server compares the Logical Name values in the request packet with the corresponding Profile Field in the AAA database.

mapgwdriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.

mapgwdriver.valuemapping=This parameter is used to specify the value mapping in case the attribute configured in the mapping expression have more than 1 value.

mapgw.querytimeout=&quot;Maximum Query Timeout Count&quot; parameter value refers to the maximum count of consecutive &quot;query timeout&quot; occurrence after which the Server Manager should mark the database as &quot;dead&quot;.<br><br>\
The database marked as &quot;dead&quot; will be marked &quot;live&quot; once it is up and running. <br><br>\
<b>Default Value:</b> 100 <br><br>\
<b>Maximum Value: </b>10000 <br><br>\

driver.mapgwconnpoolsize=This parameter specifies the maximum number of connections that are to be established between the EliteAAA server and the Ulticom MAP-GW.<br><br>\
<b>Default Value:</b> 10 <br><br>\
<b>Maximum Value: </b>30 <br><br>\

driver.requesttimeout=The &quot;Request Timeout&quot; parameter is used for specifying the duration after which, if the database does not respond to a request, then the Server Manager should consider the &quot;Request timeout&quot; event to have occurred.<br><br>\
<b>Default Value:</b> 1000 ms <br><br>\
<b>Maximum Value: </b>3000 ms <br><br>\

driver.mapgw.statuscheckduration=&quot;Status Check Duration&quot; parameter refers to the duration after which the Map Gw Auth Driver should check for whether the connectivity with the HLR is available or not.<br><br>\
<b>Default Value:</b> 60 sec <br><br>\
<b>Maximum Value: </b> 600 sec <br><br>\

driver.mapgw.sendauthinfo=Send Auth Info

#DB Auth Driver

dbauthdriver.ds=&quot;Database Datasource&quot; refers to the name of the Datasource by which the database is identified.

dbauthdriver.tblname=&quot;Table Name&quot; parameter refers to the name of the table in the database that stores customer profiles against which authentication is to be performed.

dbauthdriver.maxquerytimeout=This parameter refers to the maximum count of query timeout after which the Server Manager marks the database as dead.<br><br>\
The database marked as dead will be marked live once it is up and running.

dbauthdriver.logicalname=This parameter refers to attribute received in the authentication request. <br>\<br>\DB Attribute corresponding to Logical Name is specified in &quot;Db field&quot; parameter.

dbauthdriver.dbattribute=EliteAAA server, on receiving an authentication request, matches the attributes therein, with the attributes in the customers&rsquo; profile in the DB. Take the &quot;User-Name&quot; attribute for instance. Now, the EliteAAA Server finds if a customer record with received Username exists in the DB or not. But how does it know that with which attribute in the DB should it match the Username?  <br>\<br>\This is where the Logical Name-DB Attribute mapping comes into picture. <br>\<br>\Say, &quot;uid&quot; is the attribute of the DB storing the Username. <br>\<br>\Thus, for mapping these attributes, you are required to specify the Logical Name, &quot;Username&quot; and DB Attribute &quot;uid&quot;. <br>\<br>\Thus, on receiving an authentication request, the EliteAAA Server compares the Logical Name values in the request packet with the corresponding DB Attributes in the DB.

dbauthdriver.profilelookup=Specifies the column name based on which the AAA server should perform profile lookup.

dbauthdriver.dbquerytimeout=This parameter specifies the duration after which, if the database does not respond to a query, the Server Manager should consider the &quot;query timeout&quot; event to have occurred.<br>\<br>\ The value for this parameter can be determined in terms of seconds.

dbauthdriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.

dbauthdriver.valuemapping=This parameter is used to specify the value mapping in case the attribute configured in the mapping expression have more than 1 value.

dbauthdriver.cacheable=This parameter specifies whether this driver should be configured as a cacheable driver or not.

dbauthdriver.primarykeycolumn=This parameter specifies the column name of the tblradiuscustomer that is to be used as primary key.  

dbauthdriver.sequencename=


#UserFile Auth Driver

ufauthdriver.filelocation=This parameter refers to the location in the EliteAAA Server Home where you want the User Files to be stored. <br>\<br>\It can be any valid location in the EliteAAA Server Home directory. <br>\<br>\For Ex: data/usersfile/usersfile1.xml

ufauthdriver.expirydate=This parameter refers to the date format of the Userfile Attribute storing expiry date of the account, if any.



#Classic CSV Driver
classiccsvdriver.header=Specifies whether the parameters of the CSV file should be displayed in the header or not.<br><br>\
The header consists of all the attributes specified in the attribute list.<br><br>\
<b>Possible Values:</b> <br>\
1.	TRUE <br>\
2.	FALSE

classiccsvdriver.delimiter=Specifies the de-limiter symbol using which different columns of the CSV file should be separated.<br><br>\
Either &quot;,&quot; (comma) or &quot;-&quot;(hyphen) can be selected as de-limiter.

classiccsvdriver.multivaluedelimiter=If an attribute is having more than one value, then this parameter specifies a delimiter that should be used to separate the values of that parameter.

classiccsvdriver.avpairseparator=Specifies a separator that is to be used to separate an attribute and its value in the csv file.

classiccsvdriver.cdrtimestamp=CDR timestamp refers to the time at which a CDR file is generated.<br><br>\
This parameter specifies the format to store the CDR timestamp.

classiccsvdriver.cdrtimestampheader = This parameter specifies the field name in the header of the CSV file. Its default value is  &quot;CDRTimeStamp&quot;.

classiccsvdriver.cdrtimestampposition = This parameter specifies the location of the timestamp field of the CSV file. Its default value is  &quot;SUFFIX &quot;.

classiccsvdriver.enclosingcharacter=Enclosing Character

classiccsvdriver.filename=This parameter is used to specify naming pattern and name of the CSV file to be generated on receipt of the Accounting Request viz. Start, Interim, or Stop.

classiccsvdriver.location=This parameter specifies the path in which directories having CSV files should be created. 

classiccsvdriver.defaultfoldername=Specifies the name of a default folder in which csv files should be stored.

classiccsvdriver.createblankfile=To understand the significance of &quot;Create Blank Files&quot; parameter, consider the following scenario: <br><br>\
&quot;File Rolling Type&quot; parameter is set to &quot;0&quot; i.e. &quot;Time&quot;.<br>\
&quot;Rolling Unit&quot; parameter is set to &quot;1&quot;, which means 1 hour. This means, the current file should be rolled by assigning it .csv extension and a new file with .inp should be created if rolling unit is reached. Whether the Rolling Unit value is reached, which in this case is 1 hour, is checked in the event of request receipt. Now consider a case that 1 hour is passed after last rolling. And hence file rolling does not take place. Even after 2 hours, a request is received and the file is rolled up and a new .inp file is created. <br><br>\
Under such circumstances, when the administrator looks at the .csv files generated he may mistakenly conclude that 2 files for 1 hour each, are missing. Even though the fact is that file rolling was not performed for 2 hours since a request was not received. &quot;Create Blank Files&quot; parameter can be set to &quot;True&quot; so that in case of non-receipt of request, file rolling takes place with a blank a blank file created and rolled.

classiccsvdriver.prefixfilename= This parameter refers to the name by which the CDRs will be dumped in this directory.<br><br>\
This file name will be created with the attribute, configured in this field, as a prefix. We have given the support for configuring multiple attributes using comma &quot;,&quot; separator. <br><br>\
Suppose that &quot;0:4&quot; viz. NAS-IP-Address is configured here, then all the CDRs will be stored as per NAS-IP-Address from where the request is received, i.e. a CDR coming from a certain NAS will be dumped with a file name comprising that particular NAS-IP-Address as prefix.

classiccsvdriver.foldername=It refers to the directory that is to be created to dump the CDR files. <br><br>\
This folder name will be created with the attribute, configured in this field, as a prefix.<br><br>\
Suppose that &quot;0:4&quot; viz. NAS-IP-Address is configured here, then all the CDRs will be stored based on the NAS-IP-Address, i.e. a CDR coming from a certain NAS will be dumped in the directory created for that particular NAS. <br><br>\
The Folder Name will be the NAS-IP-Address. <br><br>\
So for each NAS a separate directory will be created in the specified Location.

classiccsvdriver.rollingtype=Specifies on what basis the CDR files must be rolled. <br><br>\
<b>Possible Values:</b> <br>\
1.	Time-Based (min) <br>\
2.	Size-based (kb) <br>\
3.	Record-Based (No. of Records)

classiccsvdriver.rollingunit=The value of Rolling Unit parameter should be in Minutes. 

classiccsvdriver.sequencerange=When an accounting request packet is received by the Radius server, it will be dumped in a cdr file in csv format.<br><br>\
This parameter specifies the range for naming the CDR files.Sequence range can be provided in [ ] (square brackets).<br><br>\
<b>Sample value:</b> [1-1000] or [a-z].  <br>\<br>\
Where, 1 is the start value and 1000 is the end value. br><br>\
So, the CDR files will be sequenced starting from 1 or a.

classiccsvdriver.sequenceposition=This parameter specifies whether to add the sequence range as a prefix or suffix, to the CDR file name.<br><br>\
<b>Possible Values:</b> <br>\
1.	Prefix <br>\
2.	Suffix

classiccsvdriver.sequenceglob=If this parameter is set to true, then all the generated CDRs will be dumped in different directory (ies) as per the continuous sequencing of the CDRs, i.e. the sequence number of CDRs will be in sync irrespective of different directories.<br><br>\
If set to false, then the CDRs dumped in different directories will follow different sequence numbers i.e. each directory will have a separate set of sequence numbers beginning with the start value.

classiccsvdriver.protocol=This parameter is used to define the file transfer protocol.<br><br>\
If Local is configured, all the CDR files will be stored locally.<br><br>\
If <b>FTP</b> is configured, then FTP protocol will be used to store the CDR files on some remote location.<br><br>\
If <b>SMTP</b> is configured, then all the files will be sent to some intended recipient.

classiccsvdriver.ipaddress=If FTP protocol is configured, then IP address of remote location should be configured in this field.<br><br>\
----------------------------------------------------------------------------------------------<br><br>\
If SMTP is configured, then destination email address should be stored in this field.

classiccsvdriver.port=This field is used to store the port number on which FTP Server listens or the port on which SMTP protocol will establish a connection for sending the CDR files.

classiccsvdriver.remoteloc=Specifies the location of remote server.

classiccsvdriver.username=This parameter stores the username of the FTP server in case FTP protocol is being used for CDR file transfer on remote machine.<br><br>\
In case SMTP protocol is being used to forward the CDR files, the senders Email Address will be configured in this parameter.

classiccsvdriver.password=Specifies the password of the FTP protocol if FTP protocol is being used for CDR file transfer.<br><br>\
And the password of SMTP protocol will be stored in this field, if SMTP protocol is being used for CDR file transfer.

classiccsvdriver.postoperation=Specifies the operation to be performed by the driver after successfully transferring the files to some remote location.<br><br>\
<b>Possible Values:</b><br><br>\
1.	Delete: delete the file <br>\
2.	Archive: store the file at some specified location <br>\
3.	Rename: rename the file

classiccsvdriver.archiveloc=Specifies the location on which the .csv file should be archived.

classiccsvdriver.failovertime=This parameter is used to specify the failover time (in minutes) to make a retry attempt, in case the CDR files were not uploaded previously due to some failure reasons.

classiccsvdriver.usedicval=Value of certain Attributes coming in the Accounting requests is received in the form of the integers having a specific meaning.<br><br>\
The Dictionary to which the attributes belong contains the meaning of each of the possible integer values.<br><br>\
You can select whether to insert the value received in the Accounting Request i.e. the integer value, as it is or insert the understandable value from the Dictionary.<br><br>\
If this parameter is set to true, then the dictionary value corresponding to the attribute received in the accounting request is inserted in the .csv file. <br>\<br>\If set to false, then the same integer value, received in the request, will be inserted in the .csv file.

classiccsvdriver.stripattributeid=Strip Attribute List should be configured to strip off a particular part of the Attribute Value before inserting it in the .csv file.

classiccsvdriver.pattern=This parameter requires being set if the Strip parameter is set to &quot;True&quot;.<br><br>\
Either the prefix or suffix of pre-defined separator can be stripped off. Strip parameter, if set to &quot;True&quot;, the driver first removes the prefix or suffix of the separator as per the setting of Pattern and Separator attribute and then inserts the resultant value in the .csv.

classiccsvdriver.separator=This parameter requires being set if Strip parameter is set to &quot;True&quot;.<br><br>\
The EliteAAA Server strips off either the prefix or suffix of the value of the Attribute selected in the Attribute section of Strip Attribute List and then inserts the value in .csv file.<br><br>\
The prefix and suffix are considered based on the separator that you specify in the Separator attribute.

classiccsvdriver.Attid=Attribute ID refers to the Attribute Id of the RADIUS attribute that you intend to save in the CSV file that is to be generated after EliteAAA Server receives the Accounting Request.<br><br>\
This could be the name of a RADIUS attribute, a Vendor-Specific attribute or even a custom attribute that is neither a RADIUS attribute nor a Vendor-Specific attribute, but you want the attribute to always be stored in the CSV file. 

classiccsvdriver.header=The Header parameter refers to the header name which will be at the top of the column in which the correspondingly configured attribute, is stored in the .CSV file. 

classiccsvdriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.

classiccsvdriver.dicvalue=If Use Dictionary Value parameter is set to True then not the integer value in the request, but the corresponding understandable string from the Dictionary will be inserted in the .csv file.<br><br>\
If set to False, the same integer, received in the request is inserted in the concerned column of the .csv file.   

classiccsvdriver.enclosingcharacter=Value Enclosing Character


classiccsvdriver.timeboundry=Time-Boundry
classiccsvdriver.sizebasedrollingunit=The value of Size Based Rolling Unit parameter will be in no of kbs. 
classiccsvdriver.timebasedrollingunit=The value of Time Based Rolling Unit parameter will be in Minutes. 
classiccsvdriver.recordbasedrollingunit=The value of Record Based Rolling Unit parameter will be in no of Records.


#Detail Local Driver

detaildriver.eventdate=This parameter specifies the format in which the event date i.e. the date on which Acct. Start, Interim or Stop request was received.<br><br>\
<b>Default Value:</b> EEE dd MM, yyyy, hh:mm:ss aaa

detaildriver.writeAttributes=This parameter determines whether all the attributes received in the Accounting Request should be inserted in the .local file or only the ones configured in Attribute List should be inserted in the file.<br><br>\
<b>Possible Values:</b> <br>\
1.	All <br>\
2.	Configured <br>\<br>\
<b>Configured</b><br>\
If this parameter is set to &quot;Configured&quot; means  only the attributes configured in Attribute List will be inserted in the .local file.<br><br>\
------------------------------------------------------------------------------<br><br>\
<b>All</b><br>\
Setting this parameter to &quot;All&quot; means all attributes of the received Accounting Request will be inserted in the .local file.

detaildriver.usedicval=Value of certain Attributes coming in the Accounting requests is received in the form of the integers, each of which have a specific meaning.<br><br>\
The Dictionary to which the attributes belong contains the meaning of each of the possible integer values.<br><br>\
You can select whether to insert the value received in the Accounting Request i.e. the integer value, as it is or insert the understandable value from the Dictionary.<br><br>\
If this parameter is set to true, then the dictionary value corresponding to the attribute received in the accounting request is inserted in the .local file.<br><br>\
If set to false, then the same integer value, received in the request, will be inserted in the .local file.

detaildriver.avpairseperator=Specifies a symbol by which the Attribute-Value pair in the incoming Accounting requests should be separated.

detaildriver.filename=Specifies the name of .local file

detaildriver.location=Specifies the location of .local file

detaildriver.defaultdirname=Specifies the name of the default folder for storing the .local file

detaildriver.prefixFileName= This parameter refers to the name by which the CDRs will be dumped in this directory. This file name will be created with the attribute, configured in this field, as a prefix. We have given the support for configuring multiple attributes using comma &quot;,&quot; separator.<br><br>\
Suppose that &quot;0:4&quot; viz. NAS-IP-Address is configured here, then all the CDRs will be stored based on the NAS-IP-Address, i.e. a CDR coming from a certain NAS will be dumped with a file name comprising that particular NAS-IP-Address as prefix.

detaildriver.foldername=Specifies to the directory that is to be created for dumping the CDR files.<br><br>\
This folder name will be created with the attribute, configured in this field, as a prefix.<br><br>\
Suppose that &quot;0:4&quot; viz. NAS-IP-Address is configured here, then all the CDRs will be stored based on the NAS-IP-Address, i.e. a CDR coming from a certain NAS will be dumped in the directory created for that particular NAS. <br>\<br>\The Folder Name will be the NAS-IP-Address. <br>\<br>\So for each NAS a separate directory will be created in the specified Location.

detaildriver.filerollingtype=Specifies on what basis the CDR files must be rolled.<br><br>\
<b>Possible Values:</b> <br>\
1.	Time-Based (min) <br>\
2.	Size-based (kb) <br>\
3.	Record-Based (No. of Records)

detaildriver.rollingunit=The value of Rolling Unit parameter will be in Minutes.

detaildriver.range=When an accounting request packet is received by the Radius server, it will be dumped in a .local file.<br><br>\
This parameter specifies the range for naming the CDR files. <br><br>\
<b>Sample value:</b> 1-10  <br>\<br>\
Where, 1 is the start value and 10 is the end value. <br>\<br>\
So, the CDR files will be sequenced starting from 1.


detaildriver.pos=This parameter specifies whether to add the sequence range as a prefix or suffix, to the CDR file name. <br><br>\
<b>Possible Values:</b> <br>\
1.	Prefix<br>\
2.	Suffix

detaildriver.global=If this parameter is set to true, then all the generated CDRs will be dumped in different directory (ies) as per the continuous sequencing of the CDRs, i.e. the sequence number of CDRs will be in sync irrespective of different directories. <br><br>\
If set to false, then the CDRs dumped in different directories will follow different sequence numbers i.e. each directory will have a separate set of sequence numbers beginning with the start value.

detaildriver.protocol=This parameter is used to define the file transfer protocol. <br><br>\
If Local is configured, all the CDR files will be stored locally. <br><br>\
If FTP is configured, then FTP protocol will be used to store the CDR files on some remote location.<br><br>\
If SMTP is configured, then all the files will be sent to some intended recipient.

detaildriver.ipaddress=If FTP protocol is configured, then IP address of remote location should be configured in this field. <br><br>\
If SMTP is configured, then destination email address should be stored in this field.

detaildriver.port=This parameter is used to store the port number on which FTP Server listens or the port on which SMTP protocol will establish a connection for sending the CDR files.

detaildriver.remoteLocation=Specifies the location of remote server

detaildriver.username=This parameter stores the username of the FTP server in case FTP protocol is being used for CDR file transfer on remote machine. <br><br>\
And sender Email Address will be configured in this parameter, in case SMTP protocol is being used to forward the CDR files.

detaildriver.password=Specifies the password of the FTP protocol if FTP protocol is being used for CDR file transfer. <br><br>\
And the password of SMTP protocol will be stored in this field, if SMTP protocol is being used for CDR file transfer.

detaildriver.postoperation=Specifies the operation to be performed by the driver after successfully transferring the files to some remote location. <br>\
1.	Delete: delete the file <br>\
2.	Archive: store the file at some specified location <br>\
3.	Rename: rename the file

detaildriver.archiveloc=Specifies the location on which the .local file should be archived.

detaildriver.failovertime=This parameter is used to specify the failover time (in minutes) to make a retry attempt, in case the CDR files were not uploaded previously due to some failure reasons.

detaildriver.attributeid=Attribute ID refers to the name of the RADIUS attribute that you intend to save in the .local file to be generated after EliteAAA Server receives the Accounting Request. This could be the name of a RADIUS attribute, a Vendor-Specific attribute or even a custom attribute that is neither a RADIUS attribute nor a Vendor-Specific attribute, but you want the attribute to always be stored in the .local file.

detaildriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. <br>\<br>\ Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.

detaildriver.dicvalue=If the Use Dictionary Value parameter is set to True, it means that the attribute values to be taken from the Dictionary and inserted in the file, and not the integer values received in the request.<br><br>\
This parameter is applied to all attribute values to be inserted in the .local file. 



#DB Acct Driver

dbacctdriver.ds=Specifies the name of the data source specified for this database, in the Oracle Database Configuration.

dbacctdriver.dstype=Specifies the type of datasource. <br>\ <br>\
<b>Sample Value:</b> Oracle

dbacctdriver.querytimeout=This parameter specifies the duration after which, if the database does not respond to a query, the Server Manager should consider the &quot;query timeout&quot; event to have occurred.<br><br>\
The value for this parameter can be determined in terms of seconds.

dbacctdriver.maxquerytimeout=This parameter refers to the maximum count of query timeout after which the Server Manager should mark the database as dead. <br><br>\
The database marked as dead will be marked live once it is up and running.

dbacctdriver.multivalDelimeter=When an accounting request is received by the driver, the attributes will be stored in the database.<br><br>\
If multiple values of same attribute are received in the accounting request, then the driver will dump all the values, separated by a delimiter, in same column.

dbacctdriver.cdrTablename=It refers to the name of the table in the database that stores customer profiles against which authentication is to be performed.

dbacctdriver.cdrIdDbField=A unique session id is assigned to every entry in the CDR table.<br><br>\
This id is unique and should not be auto incremented in order to store more records.

dbacctdriver.cdrIdSeqName=The database use sequences to manage the unique session ID generation. Sequences are entities which generate unique IDs.<br><br>\
To address the sequences, each sequence has a unique sequence-name. <br><br>\
<b>Sample Value:</b> seq_tblradisucdr

dbacctdriver.storestprec=It determines whether the Accounting Stop record should be stored in the interim table or not.<br><br>\
If this parameter is set to True then, upon receiving an accounting stop request, it will be stored in the interim table and a CDR will be generated and stored in CDR table.<br><br>\
If this parameter is set False then, the Accounting Stop will not be stored in the interim table and directly the CDR will be generated and stored in CDR table.

dbacctdriver.interimTblnm=It refers to the name of the table in the database that stores the interim records of customer against which accounting is to be performed.

dbacctdriver.interimCdrIdDbField=A unique session id is assigned to every entry in the CDR table.<br><br>\
This id is unique and should not be auto incremented in order to store more records.

dbacctdriver.interimCdrIdSeqName=The database use sequences to manage the unique session ID generation. Sequences are entities which generate unique IDs.<br><br>\
To address the sequences, each sequence has a unique sequence-name. <br>\<br>\
<b>Sample Value</b>: seq_tblradisucdr

dbacctdriver.storeInterimRec=This parameter determines whether the Accounting Interim record should be stored in the interim table or not.<br><br>\
If this parameter is set to True then when an Accounting Interim request is received, the interim record for the session in the interim table will be updated with new details. <br>\
If set to False then the Accounting Interim will not be stored in the interim table.

dbacctdriver.removeInterimOnStop=This parameter determines what should be done with the interim records of the session after a CDR is generated; whether they should be maintained in the database or removed once CDR is generated. <br>\<br>\
If this parameter is set to True, then the interim records will be removed from the interim table as soon as CDR is generated and stored in CDR table. <br><br>\
If set to False, then the interim records will be kept as it is in the interim table even after CDR generation.

dbacctdriver.callStartFieldName=This attribute define the start value of the id generation.<br><br>\
<b>Default value:</b> 1

dbacctdriver.callEndFieldName=This attribute specifies the end value for id generation.

dbacctdriver.createDateFieldName=This parameter specifies the date on which the session was created.

dbacctdriver.lastModifiedDateFieldName=This parameter specifies the date on which the session was last modified.

dbacctdriver.timestamp=CDR timestamp means the service usage time, recorded in the CDR. 

dbacctdriver.enabled=This parameter should be set to True if you want the usage start time stamp to be recorded in the database.

dbacctdriver.attid=This parameter refers to attribute received in the accounting request. DB Attribute corresponding to Logical Name is specified in Db field parameter.

dbacctdriver.dbfield=This parameter refers to the DB field attribute that is to be used for mapping.

dbacctdriver.datatype=Data Type attribute refers to the data type of the field which you are mapping with the Database. This data type could be either string, number or date.

dbacctdriver.defaultvalue=It might happen sometimes that a particular attribute, in the Accounting Request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in the Attribute section under consideration.  

dbacctdriver.dicvalue= If Use Dictionary Value parameter is set to True then not the integer value in the request, but the corresponding understandable string from the Dictionary is inserted in the .local file.<br><br>\
If set to False, the same integer, received in the request is inserted in the concerned column of the .local file.   

driver.dbDateField=DateField

cresteldriver.transaltionmappingconfiguration=Translation Mapping Configuration
cresteldriver.numberofinstance=Number of Instance

diameterchargingdriver.serviceaddress=Service Address
diameterchargingdriver.socketreceivebuffer=Socket Receive Buffer
diameterchargingdriver.socketsendbuffer=Socket Send Buffer
diameterchargingdriver.queuesize=Queue Size
diameterchargingdriver.minthread= Minimum Thread
diameterchargingdriver.maxthread=Maximum Thread
diameterchargingdriver.mainthreadpriority=Main Thread Priority
diameterchargingdriver.workerthreadpriority=Worker Thread Priority
diameterchargingdriver.owndiameteruri=Own Diameter URI
diameterchargingdriver.owndiameteridentity=Own Diameter Identity
diameterchargingdriver.owndiameterrealm=Own Diameter Realm
diameterchargingdriver.disconnecturl=Disconnect URL
diameterchargingdriver.transmapconf=Translation Mapping Configuration
diameterchargingdriver.routingtablename=Routing Table Name
diameterchargingdriver.sessioncleanupinterval=Session Cleanup Interval-TW
diameterchargingdriver.sessiontimeout=Session Timeout

driver.dc.serviceaddress=Specifies the service address of the server on which Diameter service is running.

driver.dc.socketreceivebuffer=Socket Receive Buffer Size parameter is used to specify the storage space for incoming client requests. This can be increased to accommodate large number of concurrent requests, if required. However it is suggested that you do not tamper with the default value. In case the buffer size is decreased, there is a chance of server crashing during peak hours. Thus, ensure that you specify an appropriate value for the \u201CSocket Receive Buffer Size\u201D parameter.
Also, each operating system has a default socket buffer size associated with it. If you want this default socket buffer size to be considered than specify \u201C-1\u201D as value in this parameter else specify integer as desired.
Default value= -1

driver.dc.socketsendbuffer =Socket Send Buffer Size parameter is used to specify the storage space for outgoing requests from the EliteDiameter Server. This can be increased to accommodate large number of concurrent requests, if required. However it is suggested that you do not tamper with the default value. In case the buffer size is decreased, there is a chance of server crashing during peak hours. Thus, ensure that you specify an appropriate value for the \u201CSocket Receive Buffer Size\u201D parameter.Also, each operating system has a default socket buffer size associated with it. If you want this default socket buffer size to be considered than specify \u201C-1\u201D as value in this parameter else specify integer as desired..Default value = -1

driver.dc.queuesize= Queue Size parameter refers to the maximum number of requests for Authentication Service that can be there in the request queue within the thread pool, at a given point in time. Once the queue has received request up to the number specified in this parameter, it will not accept any more requests to be queued. New requests will be dropped until there is room for new requests.For example, if you\u2019ve set \u201CQueue Size\u201D as \u201C1500\u201D, this means that at a given point in time the queue can have at the most 1500 requests. Once the queue has 1500 requests, if it receives a new request, it will be dropped. Now, if one request, out of the 1500 requests is processed then the new request (only one) will be accommodated.

driver.dc.minthread=Threads that perform tasks reside in thread pool. Upper limit and lower limit for threads are maintained, to control the number of threads existing in the thread pool. Minimum Thread refers to the minimum number of thread(s) that the thread pool should have at a given point in time.For example, if \u201CMinimum Thread\u201D is specified \u201C1\u201D, then this means that the thread pool should have atleast 1 thread in the pool at any given point in time.Default Value= 3

driver.dc.maxthread=Threads that perform tasks reside in thread pool. Upper limit and lower limit for threads are maintained, to control the number of threads existing in the thread pool.Maximum Thread refers to the maximum number of thread(s) that the thread pool should have at a given point in time.For example, if \u201CMaximum Thread\u201D is specified \u201C1\u201D, then this means that the thread pool should have at the most 1 thread in the pool at any given point in time.Default value= 5

driver.dc.mainthreadpriority=Threads that perform tasks reside in thread pool. Out of all threads existing in the thread pool, there are certain threads which perform the task of delegating tasks to the other threads. A thread which assigns tasks to other threads is called \u201CMain Thread\u201D.Value specified in \u201CMain Thread\u201D parameter refers to the maximum number of main threads that can exist in the thread pool.Default value= 8

driver.dc.workerthreadpriority=Threads that perform tasks reside in thread pool. Out of all threads existing in the thread pool, there are certain threads which perform the task of delegating tasks to the other threads. A thread which assigns tasks to other threads is called \u201CMain Thread\u201D. The threads which receive task orders from Main Threads are called \u201CWorker Threads\u201D.Value specified in \u201CWorker Thread\u201D parameter refers to the maximum number of worker threads that can exist in the thread pool.Default value= 6

driver.dc.owndiameteruri=This parameter refers to the diameter URI of charging gateway i.e. IP and Port on which charging gateway service listens to diameter interface.Examples:aaa://host.example.com:6666;protocol=diameteraaa://host.example.com:6666;transport=tcp;protocol=diameterDefault Value: aaa://localhost:3868

driver.dc.owndiameteridentity=Diameter Identity value is used to uniquely identify a DiameterNode, i.e. it specifies identity of a diameter interface of charging gateway service.

driver.dc.owndiameterrealm=Own Diameter Realm

driver.dc.disconnecturl=Disconnect URL

routingconf.tablename=Table Name


#ESI

esi.name=Specifies the name of the external system that you want to create.

esi.esitype=Specifies the type of ESI that you want to create.

esi.address=Specifies the ip address of the external system

esi.sharedsecret=Shared Secret parameter specifies a case-sensitive password used to validate the communication between EliteAAA server and any External system. 

esi.timeout=Timeout parameter refers to the duration for which the external system waits to receive a request from the EliteAAA server.

esi.statuscheckduration=Status Check Duration parameter refers to the duration after which the EliteAAA server should check whether the connectivity with the External system is available or not. <br><br>\
Value of this parameter is set in terms of Seconds.

esi.retrycount=Retry Count refers to the total number of retry attempts that can be undertaken to send a request to any external server.

esi.realmnames=

esi.minlocalport=This parameter specifies the minimum number of local port that is to be used to send request to this particular ESI instance.  

esi.expiredrequestlimitcount=This parameter specifies the total number of requests for which AAA waits to receive response from the ESI. If the ESI does not responds back after receiving this no. of requests, the AAA server will mark this ESI as dead.

esi.realmnames=

esi.minlocalport=

esi.expiredrequestlimitcount=

esi.description=

esi.supportedattribute=Supported Attribute

esi.unsupportedattribute=Unsupported Attribute


#EAP Configuration

eapconfig.name=Specifies the name of EAP Configuration.
eapconfig.desc=Description
eapconfig.cleanupinterval=A backend process is scheduled to run at regular interval of time, to flush the closed sessions from the memory, and this process is scheduled to run automatically after the time duration which is set in &quot;Session Cleanup Interval&quot; has elapsed.<br><br>\
The value of Session Cleanup Interval is specified in terms of seconds. <br><br>\
<b>Default Value:</b> 86400
eapconfig.cleanupduraiton=This parameter refers to the duration after which the closed up sessions will be removed from the system.
eapconfig.sessiontimeout=Session Timeout refers the time duration for which the Authentication server waits for every single response from the client.<br><br>\
After this time duration has elapsed, a Session Timeout occurs and the session will be closed.
servermgr.eapconfig.mskrevalidationtime =This Parameter specifiy MSK Revalidation Time in Second.
eapconfig.invalidpacket=If this parameter is set as &quot;True&quot;, then the packet which is not valid will be dropped and will not be forwarded for further processing.<br><br>\
And if this parameter is set as &quot;False&quot;, then the packet will be forwarded for further processing, even though it is invalid.
eapconfig.negotiationmethod=This parameter refers to the EAP authentication method for server-client communication.<br><br>\
EAP framework supports multiple authentication method out of which EliteAAA supports <b>MD5-Challenge, TLS, TTLS, PEAP, MS-CHAPV2, EAP-PAP, EAP-CHAP, EAP-MSCHAP </b> etc.
eapconfig.notificationsuccess=This parameter determines whether the Success Notification should be sent to the client or not.<br><br>\
If this parameter is set as &quot;True&quot; then a Notification Success message will be sent to the client, before the Access-Accept message, on successful authentication.<br><br>\
If set to &quot;False&quot; then an Access-Accept message will be sent directly to the client, without prior notification, on successful authentication.
eapconfig.notificationfailure=This parameter determines whether the Failure Notification should be sent to the client or not. <br>\<br>\If this parameter is set as &quot;True&quot; then a Notification Failure message will be sent to the client, before the Access-Reject message, if the authentication process is failed. <br>\<br>\If set to &quot;False&quot; then Access-Reject message will be sent directly to the client, without prior notification, on failed authentication.
eapconfig.maxpacketsize=This parameter determines to the maximum packet size in case of  EAP based authentication. </br></br> <b> Default Value: </b> 1024
eapconfig.authmethods=This parameter specifies the EAP methods supported by Radius server. <br>\<br>\Here, you can also configure comma separated or semicolon separated list of EAP method types. <br>\<br>\For example; 4;13,21 <br>\<br>\EAP Method Type and its value pair is as given below: <br>\<br>\<b>4: EAP-MD5 </b><br>\<b>13: EAP-TLS</b> <br>\<b>21: EAP-TTLS </b><br>\<br>\Ex: If 0 is specified as the value of this parameter, then all the EAP methods will be enabled by default.
eapconfig.majorversion=&quot;Major Version&quot; parameter refers to the major value of the protocol version. <br>\<br>\When a TLS client and server first starts communicating, they agree on a protocol version. 
eapconfig.minorversion=&quot;Minor Version&quot; parameter refers to the minor value of the protocol version. <br>\<br>\When a TLS client and server first starts communicating, they agree on a protocol version.
eapconfig.sessionresumptionlimit=This parameter specifies that how many times a session can be resumed. <br>\<br>\If 0 is specified then session resumption will not be done, -1 is for unlimited session resumption and any other value greater than 0 will allow session resumption for the number of times specified in this parameter.
eapconfig.sessionresumptionduration=&quot;Session Resumption Duration&quot; parameter comes into picture when re-auth request is sent to the client amidst the authentication process. <br>\<br>\When a re-auth request is sent to the client with the session id, within the time duration which is set in Session Resumption Duration, the authentication process will continue as it is. <br>\<br>\If the re-auth request, with the session id, is not sent within this specified time duration, then the authentication process will be discontinued and the whole process will have to be started again.  <br>\<br>\This value is specified in terms of seconds.  
eapconfig.defaultservercertname=In order to provide trusted network security services to the Radius client, EliteAAA Server must be able to cryptographically identify itself to clients. <br>\<br>\To prove its identity to clients, it sends them its digital certificate during the client login procedure. <br>\<br>\This is the default server certificate which will be sent to that every client, for which vendor specific certificates are not configured specifically in the Vendor Certificate Set. <br>\<br>\<b>Note<b>: Certificates have .pem extension
eapconfig.privatekeyname=A string well known to server and used to validate and/or encrypt data, transmitted from client to the server. <br>\<br>\This is the private key of the default server certificate. </br></br> <b>Note:The private key should be in .der format.</b>
eapconfig.defaultcacertname=A CA Certificate Authority issues digital certificates that contain a public key and the identity of the owner. The matching private key is not similarly made available publicly, but kept secret by the end user who generated the key pair. </br></br>The certificate is also an attestation by the CA that the public key contained in the certificate belongs to the person, organization, server or other entity noted in the certificate. A CA obligation in such schemes is to verify an applicants credentials, so that users and relying parties can trust the information in the CAs certificates. CAs use a variety of standards and tests to do so. <br>\<br>\If the user trusts the CA and can verify the CAs signature, then he can also verify that a certain public key does indeed belong to whoever is identified in the certificate. <br>\<br>\This is the default CA certificate irrespective to any vendor specific certificate configuration in the Vendor Certificate Set. <br>\<br>\<b>Note<b>: Certificates have .pem extension
eapconfig.certtype=The Certificate Type parameter refers to the type of the certificate being sent to the client by the server. 
eapconfig.ciphersuite=In order to communicate securely, a TLS client and TLS server must agree on the cryptographic algorithms and keys that they both will use for a secured connection. <br>\<br>\They must agree on these items: <br>\<br>\1) Key Establishment Algorithm such as RSA, DH, or ECDH <br>\ 2) Peer Authentication Algorithm such as RSA, DSA, ECDSA Bulk Data Encryption Algorithm such as RC4, DES, AES and key size <br>\3)	Digest Algorithm for Message Authentication Checking SHA1, SHA256 <br>\<br>\TLS does not allow all possible combinations of choices from those categories to be used. <br>\<br>\Instead TLS allows only certain well defined combinations of those choices, known as Cipher Suites. <br>\<br>\The TLS and TTLS protocols are capable of using a variety of cryptographic techniques for authentication and data privacy between client and a RADIUS server. <br>\<br>\Each of these techniques is called a cipher suite. Each Cipher Suite is represented by a 16-bit number.
eapconfig.ttlscertificaterequest=When &quot;TTLS Certificate Request&quot; parameter is set as &quot;True&quot; and the authentication method is TTLS, then AAA server will request a certificate from the client, to authenticate the client, for the selected cipher suite.</br></br> Alternatively, if this parameter is set as &quot;False&quot; then no client certificate request will be sent to the client. 
eapconfig.tlscertificaterequest=When &quot;TLS Certificate Request&quot; parameter is set as &quot;True&quot; and the authentication method is TLS, then AAA server will request a certificate from the client, to authenticate the client, for the selected cipher suite.  </br></br>Alternatively, if this parameter is set as &quot;False&quot; then no client certificate request will be sent to the client.
eapconfig.peapcertificaterequest=When &quot;PEAP Certificate Request&quot; parameter is set as &quot;True&quot; and the authentication method is PEAP, then AAA server will request a certificate from the client, to authenticate the client, for the selected cipher suite.  </br></br>Alternatively, if this parameter is set as &quot;False&quot; then no client certificate request will be sent to the client.
eapconfig.vendoridentifier=&quot;Vendor ID&quot; attribute is used to specify a unique ID of the vendor of the NAS. </br></br>The value that you specify for vendor identifier attribute must match to the corresponding value specified for that vendor in the Dictionary file. </br></br>This parameter configuration is in respect to the vendor specific server certificate, private key and CA certificate configuration, i.e. the server certificate which is to be sent to the client of this vendor. 
eapconfig.servercertname=In order to provide trusted network security services to the Radius client, EliteAAA Server must be able to cryptographically identify itself to clients. To prove its identity to clients, it sends them its digital certificate during the client login procedure. <br>\<br>\This is the default server certificate which will be sent to that every client, for which vendor specific certificates are not configured specifically in the Vendor Certificate Set. <br>\<br>\The vendor specific server certificate is configured for scenarios, wherein different server certificate i.e. a certificate created with different validation parameters may be required for a certain specific vendor client. <br>\<br>\In such scenario, the certificate configured in this parameter will override the default server certificate configured in the Default Server Certificate parameter. <br>\<br>\Note: Certificates have .pem extension.
eapconfig.privatekeyname=A string well known to server and used to validate and/or encrypt data, transmitted from client to the server. <br>\<br>\ This is the private key of the vendor specific server certificate. <br>\<br>\Note: The private key should be in .der format.
eapconfig.certname=A &quot;CA (Certificate Authority)&quot; issues digital certificates that contain a public key and the identity of the owner. <br>\<br>\The matching private key is not similarly made available publicly, but kept secret by the end user who generated the key pair. <br>\<br>\The certificate is also an attestation by the CA that the public key contained in the certificate belongs to the person, organization, server or other entity noted in the certificate. <br>\<br>\A CA obligation in such schemes is to verify an applicant credentials, so that users and relying parties can trust the information in the CAs certificates. <br>\<br>\CAs uses a variety of standards and tests to do so. <br>\<br>\If the user trusts the CA and can verify the CA signature, then he can also verify that a certain public key does indeed belong to whoever is identified in the certificate. <br>\<br>\This is the default CA certificate irrespective to any vendor specific certificate configuration in the Vendor Certificate Set. <br>\<br>\</b>Note: Certificates have .pem extension</b>
eapconfig.peapversion=PEAP Version
servermgr.eapconfig.ttlsnegotiationmethod= Specifies the EAP method that is used as a tunnled authentication method.
eapconfig.gsm.sim.pseudonymmethod=Sim Pseudonym Method
eapconfig.gsm.sim.pseudonymencoding=Sim Pseudonym Encoding
eapconfig.gsm.sim.pseudonymprefix=Sim Pseudonym Prefix  
eapconfig.gsm.sim.pseudonymrootNAI=Sim Pseudonym Root Network Access Identifier(NAI)
eapconfig.gsm.sim.pseudonymAAAidentityNAI=Sim Pseudonym AAA Indetity In Root Network Access Identifier(NAI)
eapconfig.gsm.sim.fastreauthmethod=Sim FastReAuth Method
eapconfig.gsm.sim.fastreauthencoding=Sim FastReAuth Encoding
eapconfig.gsm.sim.fastreauthprefix=Sim FastReAuth Prefix  
eapconfig.gsm.sim.fastreauthrootNAI=Sim FastReAuth Root Network Access Identifier(NAI)
eapconfig.gsm.sim.fastreauthAAAidentityNAI=Sim FastReAuth AAA Indetity In Root Network Access Identifier(NAI)
eapconfig.gsm.aka.pseudonymmethod=Aka Pseudonym Method
eapconfig.gsm.aka.pseudonymencoding=Aka Pseudonym Encoding
eapconfig.gsm.aka.pseudonymprefix=Aka Pseudonym Prefix
eapconfig.gsm.aka.pseudonymrootNAI=Aka Pseudonym Root Network Access Identifier(NAI)
eapconfig.gsm.aka.pseudonymAAAidentityNAI=Aka Pseudonym AAA Indetity In Root Network Access Identifier(NAI)
eapconfig.gsm.aka.fastreauthmethod=Aka FastReAuth Method
eapconfig.gsm.aka.fastreauthencoding=Aka FastReAuth Encoding
eapconfig.gsm.aka.fastreauthprefix=Aka FastReAuth Prefix   
eapconfig.gsm.aka.fastreauthrootNAI=Aka FastReAuth Root Network Access Identifier(NAI)
eapconfig.gsm.aka.fastreauthAAAidentityNAI=Aka FastReAuth AAA Indetity In Root Network Access Identifier(NAI)
eapconfig.gsm.akaprime.pseudonymmethod=Aka\\' &#32;&#32;Pseudonym Method
eapconfig.gsm.akaprime.pseudonymencoding=Aka\\' &#32;&#32;Pseudonym Encoding
eapconfig.gsm.akaprime.pseudonymprefix=Aka\\' &#32;&#32;Pseudonym Prefix
eapconfig.gsm.akaprime.pseudonymrootNAI=Aka\\'  &#32;&#32;Pseudonym Root Network Access Identifier(NAI)
eapconfig.gsm.akaprime.pseudonymAAAidentityNAI=Aka\\'  &#32;&#32;Pseudonym AAA Indetity In Root Network Access Identifier(NAI)
eapconfig.gsm.akaprime.fastreauthmethod=Aka\\'  &#32;&#32;FastReAuth Method
eapconfig.gsm.akaprime.fastreauthencoding=Aka\\'  &#32;&#32;FastReAuth Encoding
eapconfig.gsm.akaprime.fastreauthprefix=Aka\\'  &#32;&#32;FastReAuth Prefix 
eapconfig.gsm.akaprime.fastreauthrootNAI=Aka\\'  &#32;&#32;FastReAuth Root Network Access Identifier(NAI)
eapconfig.gsm.akaprime.fastreauthAAAidentityNAI=Aka\\' &#32;&#32;FastReAuth AAA Indetity In Root Network Access Identifier(NAI)


#Translation Mapping
transmapping.type=Translation mapping is used to transform request received by one protocol to another one. <br><br>\
This parameter specifies the type of translation mapping. <br><br>\ Currently, we are supporting two types of translations: <br><br>\
1)RADIUS to Crestel Rating <br>\
2)RADIUS to Diameter <br>\
3)Diameter to Diameter<br>\
4)Diameter to Crestel Rating
translationmapconf.mappingname= Mapping Name
translationmapconf.inmessage=This parameter facilitates you in configuring a check expression which will be applied on the incoming request packets.<br><br>\
If this condition is successfully satisfied by the received request, then this mapping will be applied on the received request packet. <br><br>\
<b>Sample Value:</b>PacketType=&quot;1&quot; AND 0:6=&quot;Authorize-Only&quot;  <br><br>\
- This will be applied to authorize only requests. <br><br>\
- If the configured In Message is PacketType=&quot;1&quot; then it will be applied to all type of authentication requests.
translationmapconf.outmessage=This parameter specifies the rating method to be invoked.  <br><br>\
<b>Possible values:</b><br><br>\
1) Auth-Method<br><br>\
2) ReAuth-Method<br><br>\
3) Acct-Method
transmapping.checkexp=This is an expression that must be satisfied by the radius request for applying this mapping. <br><br>\
<b>Sample Value:</b> <br><br>\
0:1=* AND (0:89=*) <br><br>\
This means this mapping will be applied on the incoming request packets if username as well as CUI attributes are present in the radius request packet.
transmapping.mappingexp=This parameter specifies the value to be assigned to the attribute to be sent to crestel rating.<br><br>\
Ex: If we configure USERNAME=21067:125 in the mapping expression, this indicates the value of 21067:125 attribute of the radius request packet will be assigned to USERNAME key of the rating server. <br><br>\
The parameter on the LHS of the expression refers to the rating key.<br><br>\
While the parameter on the RHS refers to the radius attribute. 
transmapping.defaultvalue=This parameter refers to the value to be considered as default if value in the corresponding Attribute ID is not received in the request packet. <br><br>\
Ex: SERVICE-NAME-ACCESS
transmapping.valuemapping=The &quot;Value Mapping&quot; is used in case the value of some attribute is to be mapped with some value. <br><br>\
If value mapping configured is 1=Prepaid, 2= Postpaid and if the value received in attribute is 1 then, Prepaid will be sent to the rating server. <br><br>\
Ex: Initial-Request=INITIAL-REQUEST,Threshold\ reached=THRESHOLD-REACHED,Quota\ Reached=QUOTA-REACHED,Service\ Not\ Established=SERVICE-NOT-ESTABLISHED<br><br>\
<br><br>\
Note: If you want to insert a space in the value mapping then use escape character symbol.<br><br>\
Ex: Threshold&#92; reached=THRESHOLD-REACHED
transmapping.rescheckexp=This is an expression that must be satisfied by the response packet received from the cresting rating server. <br><br>\
Sample Value: RATE\-CARD\ TYPE=&quot;VOLUME&quot; AND LAST\- QUOTA=&quot;FALSE&quot;
transmapping.resmappingexp=This parameter specifies which rating parameter value is to be assigned to which radius attribute.<br><br>\
<b>Sample Value:</b> 24757:37=&quot;&#123;1=&lsquo;RESERVATIONID&rsquo;,2=&lsquo;SESSION-VOLUME-KB&rsquo;,3=&lsquo;VOLUME-THRESHOLD-KB&rsquo;&#125;&quot;<br><br>\
Ex: This indicates the value of the RESERVATIONID will be assigned to 24757:37:1 attribute of the radius server.<br><br>\
The parameter on the LHS of the expression refers to attribute to be present in the radius response.<br><br>\
While the parameter on the RHS refers to the rating key
transmapping.resdefaultvalue=This parameter refers to the value to be considered as default if value in the corresponding Attribute ID is not received in the request packet.<br><br>\
Ex: RESERVATIONID=123, MAX-SESSION-VOLUME-KB=123, TERMINATION-ACTION=3
transmapping.outfield=In EliteAAA, rating can be done in two ways either by using the original Rating server or by using Dummy Rating.<br>\<br>\Dummy Rating is used in case if the rating server is down.<br>\<br>\&quot;Out field&quot; parameter specifies the attribute that is to be sent in the response packet.
transmapping.value=This parameter specifies the value corresponding to the attribute configured in the out field parameter.
transmapping.script=Script
transmapping.name=Name of the translation mapping configuration
transmapping.desc=Description


#IP POOL 

ippool.name=This parameter specifies the name of ip pool being created.

ippool.status=Status

ippool.description=Description

ippool.ruleset=RuleSet

ippool.nasipaddress=This parameter specifies the nas ip address of the server on which ip pool service is running.

ippool.additionalattributes=This parameter facilitates you in configuring the additional attributes that you want to send along with Access-Accept packet in addition to the allocated Framed-Ip-Address.

ippool.startipaddress=This parameter specifies the start ip address for the ip pool being created.

ippool.endipaddress=End IP Address

ippool.file=File

ippool.totalnumber=This parameter specifies the total number of ip addresses to be allocated for this ip pool. 

ippool.ipaddress=IP Address

ippool.ipaddressrangeid=This Parameter specifies the identity of IP Address range. The value of Range id should be unique for each IP Address Range.

ippool.ipaddressrange=This Parameter facilitates for generating IP Address By Range.<br>\<br>


#Diameter Peer Profile
diameterpeerprofile.name=This parameter specifies the name of the Diameter Peer Profile<br>\<br>\<b>Example:</b> Diameter_peer_profile1, Elitecore_profile
diameterpeerprofile.description=Description
diameterpeerprofile.transportprotocol=This parameter specifies the name of the protocol that is to be used for transmission of diameter packets. Diameter Standard RFC suggests 2 protocols  TCP & SCTP.
diameterpeerprofile.socketreceivebuffersize=This parameter <b>can control the amount of incoming data traffic received by the diameter peer.</b> It is useful for overload protection.<br>\This can be increased to accommodate large number of incomming messages, if required. However it is suggested that you do not tamper  with the default value. In case, the buffer size is too high, the Server can run out of memory.<br>\<br>\<b>Note: </b>Here, <b> -1 indicates the default buffer size of the operating system.</b>
diameterpeerprofile.socketsendbuffersize=This parameter can control the amount of outgoing data traffic send by the diameter peer. It is useful for overload protection. <br>\This can be increased to accommodate large number of outgoing messages, if required. However it is suggested that you do not tamper with the default value. In case, the buffer size is too high, the Server can run out of memory.<br>\<br>\<b>Note:</b> Here, <b> -1 indicates the default buffer size of the operating system.</b>
diameterpeerprofile.tcpnagleAlgorithm=If set to true, this parameter will delay the transmission by accumulating multiple small-size packets & thus  efficiently utilizes the link. TCP Nagle Algorithm is useful in low latency link when you are sending small packets at a high rate.<br>\<br>\<b>For example: </b> When the MTU=1500 Bytes,  if this parameter is set to &#34;True&#34;, it will accumulate 5 packets of 300 bytes & send them together into a single frame of 1500 bytes. Thus, it improves the efficiency by reducing the number of frames that are sent across the network.<br>\<br>\If this parameter is set to &#34;False&#34;, it will send a single frame(1 packet of 300 bytes) at a time. Thus, 5 frames are sent & the link is not utilized efficiently.
diameterpeerprofile.dwrduration=This parameter specifies the duration after which a DWR is sent to an idle Diameter Peer. The duration is in seconds. &#34;0&#34; means no DWR will not be generated for that peer.<br>\<br>\<b>Possible Values: </b>Any valid integer. RFC recommends minimum 6 seconds.
diameterpeerprofile.initconnection=This parameter specifies the time duration after which transport connection will be retried, if the communication link is not established. The duration is in seconds.<br>\<br>\<b>\*Note: </b> If this parameter is set to &#34;0&#34;, then connection will not be initiated for that peer.<br>\<br>\<b>Possible Values:</b> Any valid integer 
diameterpeerprofile.retrycount=Retry Count
diameterpeerprofile.senddprcloseevent=Few peers neither detect dead peers without DPR nor allow any new connection. Whenever there is such problem in communication, a DPR is send & new connection will be attempted.
diameterpeerprofile.sessioncleanupon=This parameter specifies whether to clear all the sessions when CER/DPR is received from the Peer. If set to true, then the server will clean up all the existing sessions of  that Peer. There are 2 configurations to flush the in-memory  sessions \- Session Cleanup on CER & Session Cleanup on DPR.
diameterpeerprofile.ceravps=This parameter enables in configuring the additional attributes that should be added in the CER packet<br>\<br>\ <b>Possible Values:</b> Any valid Attribute value pair	<b>Example:</b> 0:267=6420 
diameterpeerprofile.dpravps=This parameter enables in configuring additional attributes that should be added in the DPR packet. <br>\<br>\<b>Possible Values:</b> Any valid Attribute value pair	<b>Example:</b> 0:266=21067
diameterpeerprofile.dwravps=This parameter enables in configuring additional attributes that should be added in the DWR request packet.<br>\<br>\ <b>Possible Values:</b> Any valid Attribute value pair	<b>Example: </b>0:278=1000
diameterpeerprofile.diameterURI=If this is set to true, while sending redirection indication Proper URI of peer will be sent in Redirect-Host AVP.Else host name of the peer will be sent in Redirect-Host AVP. 
diameterpeerprofile.followredirection=Follow redirection
diameterpeerprofile.tlsversion=TLS Version
diameterpeerprofile.mintlsversion=Minimum TLS Version
diameterpeerprofile.maxtlsversion=Maximum TLS Version
diameterpeerprofile.servercertificate=Server Certificate Profile
diameterpeerprofile.clientcertificatevalidation=Client Certificate Request
diameterpeerprofile.ciphersuitelist=CipherSuite List
diameterpeerprofile.certificateexception=Certificate Validation
diameterpeerprofile.expirydate=Expiry Date
diameterpeerprofile.unknownca=Unknown CA
diameterpeerprofile.revokedcertificate=Revoked Certificate
diameterpeerprofile.securitystandard=Security Standard
diameterpeerprofile.exclusiveauthappid=This parameter allows you to configure value of Auth-Application-Id (0:258) AVPs to be sent in CER/CEA.<br/><br/><b>Possible Values:</b><br/><br/> 1. Comma/Semi-colon separated values in VendorId:ApplicationId or Application-Id &#160;&#160;&#160; format.<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Example: 1, 4, 10415:16777302<br/><br/>2. 0xFFFFFFFF : This is interpreted as Relay Application Id <br/>3. 0x0 : This means No Auth-Application-ID AVPs will be sent in CER/CEA.
diameterpeerprofile.exclusiveacctappid=This parameter allows you to configure value of Acct-Application-Id (0:259) AVPs to be sent in CER/CEA.<br/><br/><b>Possible Values:</b><br/><br/> 1. Comma/Semi-colon separated values in VendorId:ApplicationId or Application-Id &#160;&#160;&#160; format.<br/><br/>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Example: 1, 4, 10415:16777250<br/><br/>2. 0xFFFFFFFF : This is interpreted as Relay Application Id <br/>3. 0x0 : This means No Auth-Application-ID AVPs will be sent in CER/CEA.
diameterpeerprofile.haipaddress=HA IP Address
diameterpeerprofile.dhcpipaddress=DHCP IP Address

#Diameter Peer 
diameterpeer.hostidentity=Host Identity will be used to validate the Origin-Host Attribute of a Diameter peer from where a Capability-Exchange Request is received.<br>\<br>\<b>Possible values: </b>None or valid host identity <br>\<b>Example: </b>aaa.elitecore.com, pcrf.example.com 
diameterpeer.peername=Specifies the name of the diameter peer
diameterpeer.realmname=Diameter makes the use of realm to determine whether messages can be processed locally, or they must be routed or redirected. Specifies the name of an administrative domain which provides services to a user.<br>\<br>\<b>Possible values:</b> Any valid realm name<b> Example:</b> example.com, elitecore.com 
diameterpeer.diameteteruriformat=URI Format of peer can be specified or URI  can be specified as it is. To specify URI format few keywords that can be used are:<br/><br/> $&lcub;aaa&rcub; = aaa:&sol;&sol; or aaas:&sol;&sol; if TLS is enabled <br/> $&lcub;FQDN&rcub; = &#60; Peer&rsquo;s_Host_name &#62; <br/>$&lcub;port&rcub; =&#60; :Peer&rsquo;s_Remote_Port &#62;<br/>$&lcub;transport&rcub; = ;transport= <br/>  $&lcub;tansport-protocol&rcub; = ;transport= &#60; tcp_or_sctp &#62; <br/>$&lcub;protocol&rcub; = ;protocol=  <br/>$&lcub;aaa-protocol&rcub; = ;protocol=diameter <br/><br/> <b>e.g</b> aaas://$&lcub;FQDN&rcub;$&lcub;port&rcub;;transport=tcp$&lcub;aaa-protocol&rcub; = aaas:&sol;&sol;host.example.com:9999;transport=tcp;protocol=diameter  
diameterpeer.remoteaddress=Specifies the address of a remote server in the format Host:Port, where Host can be either of FQDN, IPv4, or IPv6. If port is kept as blank, it means default port number 3868.If there is a null value in the Remote Address, then it will get the IP Address either from the Host-identity or network address of connection.
diameterpeer.name=Specifies the name of the Peer Profile to which this Peer belongs to.<br>\<br>\<b>Possible Values: </b>Any valid Peer Profile Name
diameterpeer.localaddress=Specifies our end-point address for peer connection, in format Host:Port. If unconfigured, then server will use the IP address on which the Diameter service is running. A machine can have multiple NIC cards. Local Address is the IP Address from which the diameter request is initiated for that Peer. If IP is configured as &#34;0.0.0.0&#34;, the OS picks up a dynamic local IP address for multi-homing scenario.
diameterpeer.hostidentity_remoteaddress=Host Identity / Remote Address 
diameterpeer.requesttimeout=Response should be received within the specified time.If response is not received within specified time, request is considered as timeout and eligible for retransmission.<br>\<br>\<b>Possible Value : </b><br>\===================<br>\ minimum value  : 1000<br>\ maximum Value : 10000
diameterpeer.retransmissioncount=Maximum number of retransmission for the request.<br>\<br>\ Diameter retransmits the request until configured retransmission count is reached.<br>\<br>\<b>Possible Value : </b><br>\===================<br>\ Minimum value  : 0(no retransmission) <br>\ Maximum value : 3 <br>\<br>\ <b>Note:</b> If timeout is disabled than no retransmission will occurs. 
diameterpeer.secondarypeer=Secondary Peer

#Diameter Routing Configuration
general.name=This parameter specifies the name of the Routing Entry that is to be created.
general.description=Description
routingconf.title=Routing Configuration
routingconf.create.title=Create Routing Configuration
routingconf.realmname=The Destination Realm contains the realm where the message is to be routed.  &#34;* &#34; matches everything here.<br>\<br>
routingconf.appids=Specifies the unique ID allocated to the Application. An application ID is identified by Vendor-ID:Application-ID format. A routing entry can have different destination based on application identity AVP in the message. Multiple Application ID can be configured. &#34;0&#34;  means any Application ID.<br>\<br>
routingconf.originhost=This AVP identifies the peer that originated the Diameter Message. This parameter is different then standard Diameter Origin-Host AVP. The parameter is checked with the network IP-Address of sender. &#34; *&#34; matches everything here. It is useful for source network based routing requirement.
routingconf.originrealm=This AVP contains the realm of the originator of a Diameter Message and it must be present in each Diameter messages. &#34;* &#34; matches everything here.
routingconf.ruleset=&#34;Rule Set&#34; can be used for routing based on any attribute.<br>\<br>\Here, you can configure multiple check expressions separated by &&, || and () operators. <br>\<br> 
routingconf.routingaction=The Routing Action field is used to identify how a message should be treated. <br>\<br>\<b>Possible Values:</b> Relay/Local/Proxy/Redirect<br>\<br>\<b>Local: </b>Matched Diameter messages will be <b>processed locally.</b><br>\<br>\<b>Relay:</b> Matched Diameter messages must be routed to a next hop , <b>without modifying any AVPs.</b> Typically used for DEA (Diameter Edge Agent) and LoadBalancer.<br>\<br>\<b>Proxy:</b> Matched Diameter messages that fall within this category will be forwarded to a next hop server <b>after modifying the message content.</b> The Proxy Agent may apply its local policies to the message by including new AVPs to the message prior to routing. Translation Agent also works with Proxy action.<br>\<br>\<b>Redirect:</b> Redirect Agent act as a centralized configuration repository for Diameter Application providers. When Redirect Agent receives a diameter message, it checks the Routing Table & returns a answer message along with the Redirect-Host, Result-Code=3006 and other <b>redirecton information<b> to the requester.
routingconf.statefulrouting=This parameter specifies whether  session specific stateful routing should be enabled or not. Stateful Routing maintains in\-memory session state information.This functionality will be required in rare scenarios when the peer does not provide statefulness of Destination\-Host. This setting may ignore the Destination-Host received into request. 
routingconf.attachedrouting=When this option is enabled, peer&rsquo;s hostname&sol;URI will be sent in redirection host AVP only if that peer is connected with EliteAAA. 
routingconf.peergroup=Peer Group
routingconf.peergroup.ruleset=RuleSet
routingconf.peergroup.peer=Peer
routingconf.peergroup.loadfactor=Load Factor
routingconf.tablename=Select the name of the Routing table in which this routing entry will reside. You can select any existing Routing table from the drop down list.
routingconf.table.name=This parameter specifies the name of the Diameter Routing Table. There can be multiple routing tables defined but an instance can use only one table. Different instances can use different Routing tables
routingconf.transactiontimeout=This parameter specifies the duration until which the subsequent transmission to another peer will happen. This parameter is useful only when a peer answers with Error Flag and Failure Action &#34; Failover&#34;  is configured for that Error Code. If the timout has already passed, then the answer will be passthrough to originator.
routingconf.failureactions=Diameter can encounter either Network Layer failure or Application Layer Failure. This parameter specifies the way of handling the diameter failure based on the Result code like 3000,4000,5000.<br>\<br><b>Error Codes:</b> This field contains comma separated error codes.<br>\<br><b>Failure Action: </b>This parameter specifies the failure action that is to be taken  upon receiving an answer with given error code. The drop down list contains 5 types of failure Actions-  Drop, Failover, Translate, Redirect and Passthrough. Failure Argument is Failure Action dependent string. <br>\<br>
routingconf.transmapconf=Select an existing Translation Mapping  that is to be applied on the request packet. Translation mapping will not get applied if the Routing Action is &#34; Relay&#34;. 
routingconf.peergroup=In the Routing Peer Group, based on the Ruleset satisfied, the Diameter packet is forwarded to the Destination Peer. Multiple Peers can be added with specific load factor.
routingconf.noofInstance=No Of Instance
routingconf.overloadaction=Overload Action can be Drop or Reject
routingconf.resultcode=Overload Action Response Result Code
routingconf.routingscript=If there is a requirement of implementing extra logic over routing in this case this parameter will be configured.

#Service Drivers
driver.usridentity=User Identity Attributes
driver.sendauthinfo=Send Auth Info
driver.numberoftriplets=Number Of Triplets
authpolicy.additionalgroup=Additional Group


#Creating AAA Server Instance
servermgr.servertype= Specifies the type of server for which this server instance is to created.  <br>\<br>\
<b>Possible Values</b>: AAA Server , Resource manager
servermgr.servername=Specifies the name of the server instance.<br>\<br>\
Service Instance Name does not have any significance on the Server. It is only for identifying the server out of all the server instances configured in the Server Manager. However, the Server Instance Name should be unique among all the server instances configured in the Server Manager.
servermgr.desc=Description
servermgr.admininterfaceip=Specifies the IP Address of the server on which the EliteAAA server is installed.
servermgr.admininterfaceport=Specifies the JMX port on which the EliteAAA server is installed.
servermgr.server.protocol=Specifies the protocol used for connection between the EliteAAA client and server. <br>\<br>\
<b>Default Value</b>:Telnet 
servermgr.server.shellprompt=The shell prompt is the marker on the screen that shows where the UNIX command should be placed. <br>\<br>\
This parameter specifies which shell prompt should be placed on the screen. <br>\<br>\
<b>Default Value</b>: $
servermgr.server.communicationport=Specifies the port used for the client server communication.
servermgr.server.username=Specifies the Username to be used for logging on to the machine in which the server is installed.
servermgr.server.password=password
servermgr.server.operationtimeout=Specifies the duration in terms of milliseconds for which the Telnet should wait for response from the server.
servermgr.server.failuremsg=Specify the Failure Message to be displayed in case Telnet is not able to connect to the server.
servermgr.serverhome=Specifies the path of the home directory of the EliteAAA server.
servermgr.javahome=Specifies the path of the home directory of Java.
servermgr.server.logonscripts=Specifies a script or a program in UNIX that allows login of a user.
servermgr.staffUser=This staff will be bound with current instance.

#Session Manager  --> Search Active Session
sessionmanager.asm.username= Specifies User name of the user whose active sessions are to be searched
sessionmanager.asm.nasipaddress=NAS IP Address
sessionmanager.asm.framedipaddress=Framed IP Address
sessionmanager.asm.groupname= Group Name
sessionmanager.asm.starttime=Start Time
sessionmanager.asm.acctsessionid=Acct Session Id
sessionmanager.asm.list=List
sessionmanager.asm.idletime= Idle Time
sessionmanager.asm.groupby= Group By
sessionmanager.type=Type

sessionmanager.asm.nasipaddress= Specifies IP Address of the NAS whose active sessions are to be searched

sessionmanager.asm.framedipaddress= Specifies Framed IP Address of the users whose active sessions are to be searched

sessionmanager.asm.groupname= Group Name refers to name of the Concurrent Login Policy of Policy Type &quot;Group&quot;, associated with group of users sharing an account

sessionmanager.asm.idletime= Idle Time refers to the duration in terms of Seconds, for which an Accounting Interim entry has not been received

sessionmanager.asm.groupby= Group By is related to the search result. Select the field with which you want the search result to be grouped by. <br>\<br>\
For example, if you select Group Name as Group By field, then all active sessions will be grouped together for each Group Name.


# Digest Configurations
digestconf.drafaaasipenable=Draft is a set of standards describing methods, behaviors, research or innovations applicable to the working of the internet and internet-connected systems.<br>\<br>\
Draft is similar to RFC. EliteAAA server supports RFCs for its working. In certain scenarios, you may want EliteAAA to also support standards as per Drafts.<br>\<br>\
When this parameter is set as &quot;True&quot;, the EliteAAA server will support Draft standards along with the RFC standards.<br>\<br>\
If configured as &quot;False&quot;, then the EliteAAA server will only support the RFC standards.

eapconfig.peapversion=PEAP Version



#Dictionary Management
dictionary.file=Dictionary File
dictionary.name=Name
dictionary.description=Description

#Radius Packet
radius.packetName= Specifies the name of the RADIUS packet.
radius.RadiusServerPort=Specifies the IP Address and JMX port on which the EliteAAA server is running.
radius.ReplayTimeout=Timeout refers to the duration for which the EliteAAA Server looks up a particular DB server to see if there is a record that matches the incoming authentication request. 
radius.RadiusSecretKey=This parameter refers to the shared secret which the target server and Radius server share with each other so as to validate their communication.
radius.UserName=Specifies the Username that is to be sent in a RADIUS request packet.
radius.Password=Password
radius.RequestType=Specifies the type of RADIUS packet sent to the EliteAAA server. 
radius.ClientIpPort=Specifies the Service address of the NAS client from where 
radius.Add=Add
radius.test.add.parametername=<b>Parameter name: </b><br/><br/>Select the required parameter name from the available dictionaries.<br/><br/><b>Parameter value:</b><br/><br/>Specify the value of the selected parameter.<br/>If the selected parameter is a grouped(nested) attribute, then specify the values of sub attributes in the form of<br/>sub-attribute-id-1=value-1;sub-attribute-id-2=value-2;...;sub-attribute-id-n=value-n<br/><br/>e.g.<br/> To add 3GPP2 VSA, Prepaid-Acct-Quota with sub-attributes 1,6 and 8;<br/> 1. Select parameter name as 3GPP2-Prepaid-Acct-Quota from the dictionary<br/> 2. Specify the value as:<br/> 1=11;6=1000;8=3


#BW List Data
radius.bwlist.attribute = Specifies the attribute id based on which a used is to be blacklisted.
radius.bwlist.attributevalue = Specifies the value of the attribute configured in the above field.
radius.bwlist.status=Status
radius.bwlist.validity=validity
radius.bwlist.type=Type

#Password verification
utilities.verifypwd.sharedsecret=It is the string that acts as password to validate the communication between a RADIUS Server and NAS.


utilities.verifypwd.reqauth=Radius Authenticator is received by the Radius Server in the Access-Request and it is a 16-octet number, randomly generated by the Radius Client.


utilities.verifypwd.userpwd=This parameter refers to the password of the user stored in the user profile in the authentication database.


utilities.verifypwd.chapchallenge=CHAP avoids sending passwords in clear text over any communication link. <br>\<br>\
In this authentication method, during password negotiations the NAS generates a challenge (a random string) and sends it to the user. <br>\<br>\
The user&lsquo;s PPP client creates a digest (the password concatenated with the challenge), encrypts the digest using one-way encryption, and sends the digest to the NAS. The NAS sends this digest, as the password in the Access-Request, to the Radius server.


utilities.verifypwd.chappwd=The digest generated by the PPP client by concatenating  the user password and the CHAP Challenge is encrypted by the client.<br>\<br>\
The NAS sends this digest, as the CHAP password in the Access-Request, to the Radius server. 


utilities.verifypwd.digestrealm=A string to be displayed to users so that they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.

utilities.verifypwd.digestnonce=This attribute holds a nonce to be used in the HTTP Digest calculation. <br>\<br>\
If the Access-Request had a Digest-Method and a Digest-URI but no Digest-Nonce Attribute, the RADIUS server place a Digest-Nonce Attribute into its Access-Challenge packet. <br>\<br>\
This attribute is only used in Access-Request and Access-Challenge packets.

utilities.verifypwd.digestmethod=This attribute holds the method value to be used in the HTTP Digest calculation. <br>\
This attribute is only used in Access-Request and Accounting-Request packets.

utilities.verifypwd.digesturi=This attribute is used to transport the contents of the Digest-URI directive or the URI of the HTTP-style request. <br>\<br>\
It is only used in Access-Request and Accounting-Request packets.


utilities.verifypwd.digestqop=&quot;Digest QoP&quot; is a quoted string of one or more tokens indicating the &quot;quality of protection&quot; values supported by the server.

utilities.verifypwd.digestalgorithm=&quot;Digest Algorithm&quot; refers to a string indicating a pair of algorithms used to produce the digest and a checksum. 

utilities.verifypwd.digestbody=When using the Digest-QoP value &lsquo;auth-int&rsquo;, a hash of the HTTP-style message body&lsquo;s contents is required for digest calculation. <br>\<br>\
Instead of sending the complete body of the message, only its hash value is sent.  <br>\
This hash value can be used directly in the digest calculation.<br>\
The clarifications described in section 22.4 of &#91;RFC3261&#93; about the hash of empty entity bodies apply to the Digest-Entity-Body-Hash Attribute.  This attribute MUST only be sent in Access-Request packets.


utilities.verifypwd.digestcnonce=This attribute holds the client nonce parameter that is used in the HTTP Digest calculation.  It is only used in Access-Request packets.

utilities.verifypwd.digestnoncecount=This attribute includes the nonce count parameter that is used to detect replay attacks. The attribute is only used in the Access-Request packets.

utilities.verifypwd.digestusername=This attribute holds the user name used in the HTTP Digest calculation.  <br>\
The Radius server uses this attribute only for the purposes of calculating the digest.  <br>\
This attribute is only used in Access-Request and Accounting-Request packets.

#Dictionary Management
dictionary.dictionary.file=Dictionary File
dictionary.dictionary.description=Description

#Diameter Policy
diameterpolicy.name=Name
diameterpolicy.description=Description
diameterpolicy.checkitems.expression=Check Items
diameterpolicy.rejectitems.expression=Reject Items
diameterpolicy.replyitems.expression=Reply Items
diameterpolicy.status=Status

#LDAP DataSource
ldap.name=Name

#Connection Request
userstatistics.useridentity=User Identity

#Staff
staff.name=Specifies the name of the user to be created as Staff
staff.username=Specifies the name by which the system shall identify the user
staff.password=Specifies password for user
staff.confirmpassword=Confirm password
staff.birthdate=Birth Date
staff.address1=Address 1
staff.address2=Address 2
staff.city=City
staff.state=State
staff.country=Country
staff.pincode=Pin Code
staff.emailaddress=Email Address
staff.accessgroups=Assigned Access Groups
staff.phonenumber=Phone No.
staff.mobilenumber=Mobile No.
staff.status=Specifies the status of the staff created.
staff.audit.actionname.label=Specifies the action for which you want to search the audit details.
staff.audit.auditdate.label=Specifies the date for which you want to search the audit details.
staff.audit.auditdate.name=Specifies the name for which you want to search the audit details.
staff.audit.user.label=Specifies the name of the user for which the audit details is to be searched.

#AccessGroup
accessgroup.name=Name
accessgroup.description=Description

#Webservice
webservice.dbconfig.datasource=This parameter holds the data source name by which the database is identified. <br>\<br>\
The EliteAAA Server uses the Data Source Name for referring to the database.

webservice.dbconfig.tablename=This parameter refers to the name of the table in the database that stores customer profiles against which authentication is to be performed.

webservice.dbconfig.uidfieldname=Specifies the column name based on which the AAA server should perform profile lookup.

webservice.dbconfig.recordfetchlimit=Record Fetch Limit

webservice.dbconfig.primarykeycolumn=This parameter specifies the column name of the tblradiuscustomer that is to be used as primary key.

webservice.dbconfig.sequencename=Sequence Name

webservice.dbconfig.field=This parameter specifies the column name in which the attributes received in a web service request is to be dumped. 

webservice.dbconfig.key=This parameter refers to attributes received in the web service request.

webservice.dbconfig.attribute=Attribute

webservice.dbconfig.wskey= WS-Key
webservice.dbconfig.dbfield= DB Field
webservice.dbconfig.request= Request
webservice.dbconfig.response= Response


#Service Driver

driver.header=Header
driver.filename=File Name
driver.location=Location
driver.createblankfile=Create Blank File
driver.prefixFileName=PrefixFileName
driver.defaultdirname=Default Dir name
driver.foldername=Folder Name
driver.filerollingtype=File Rolling Type
driver.range=Range
driver.rollingUnit=Rolling Unit
driver.pos=Sequence Position
driver.global=Sequence Globalization
driver.detaillocal.allocatingprotocol=Allocating Protocol
driver.ipaddress=IP Address
driver.port=Port
driver.remoteLocation=Remote Location
driver.postoperation=Post Operation
driver.archiveloc=Archive Location
driver.failovertime=Fail Over Time
driver.instname=Instance Name

driver.dbauthdriver.ds=DataSource
driver.eventDateFormat=Date Format


driver.webserviceaddress=Web Service Address
driver.smservicename=SM Service Name
driver.parleyservicename=Parley Service Name

#Certificate
server.certificate.name=This parameter specifies the name of an Server Certificate.
server.certificate.publiccert=Public Certificate
server.certificate.privatekey=Private Key
server.certificate.privatekeypassword=Private Key Password
server.certificate.privatekeyalgorithm=Private Key Algorithm

server.trustedcertificate.trustedcert=Trusted Certificate
server.trustedcertificate.name=This parameter specifies the name of an Trusted Certificate.

server.crlcertificate.crlcert=Certificate Revocation List
server.crlcertificate.name=This parameter specifies the name of an Certificate Revocation List.

#HSS Auth Driver

driver.hssdriver.useridentityattribute=UserIdentity Attribute
driver.hssdriver.applicationid=3gpp Application Id
driver.hssdriver.requesttimeout=Request Timeout
driver.hssdriver.commandcode=Command Code
driver.hhspeerconfiguration=Hss Peer Configuration
driver.hssdriver.nooftriplets=No of Triplets
driver.hhsdriver.additionalattributes=Additional Attributes
driver.peername=Peer Name
driver.weightage=Weightage
driver.hssdriver.logicalname=This parameter refers to attribute received in the authentication request. <br>\<br>\DB Attribute corresponding to Logical Name is specified in &quot;Db field&quot; parameter.
driver.hssdriver.attributeid=EliteAAA server, on receiving an authentication request, matches the attributes therein, with the attributes in the customers&rsquo; profile in the DB. Take the &quot;User-Name&quot; attribute for instance. Now, the EliteAAA Server finds if a customer record with received Username exists in the DB or not. But how does it know that with which attribute in the DB should it match the Username?  <br>\<br>\This is where the Logical Name-DB Attribute mapping comes into picture. <br>\<br>\Say, &quot;uid&quot; is the attribute of the DB storing the Username. <br>\<br>\Thus, for mapping these attributes, you are required to specify the Logical Name, &quot;Username&quot; and DB Attribute &quot;uid&quot;. <br>\<br>\Thus, on receiving an authentication request, the EliteAAA Server compares the Logical Name values in the request packet with the corresponding DB Attributes in the DB.
driver.hssdriver.defaultvalue=It might happen sometimes that a particular attribute, in the request packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.
driver.hssdriver.valuemapping=This parameter is used to specify the value mapping in case the attribute configured in the mapping expression have more than 1 value.


esi.statuscheckmethod=Method for Checking Status of ESI.\
<br /><br /> ICMP-Ping: ICMP Ping Request will be sent to ESI.\
<br /><br /> Radius-Message: Radius Packet will be sent. By default Radius-Status-Server Message will be sent. \
Any Other Radius Packet that has to be used for Scanning can be configured in Packet Bytes Parameter. \
<br /><br /> Packet-Bytes: Raw UDP Bytes will be sent for Scanning. Bytes must be configured in Packet Bytes Parameter.   
esi.packetbytes=Packet to be sent for Status Check\
<br /><br />Syntax for Radius-Message is: <br />type=radius-packet-type, [[attr-type:]attr-id=val[,[attr-type:]attr-id=val]]\
<br />Example: type=1,0:1=uname,0:2=pswrd,0:4=127.0.0.1\
<br /><br />Syntax for Packet-Bytes is: Hex String starting with 0x\
<br />Example: 0x0101002b91b2d74b0b9ac687e8873d09d8c82ce101086d6f6e696361210f31333934313034333831363133 


copypacket.parameter.operation=Operation that determines the packet operation on diameter AVP e.g. Add ,Update,Remove ,Upgrade
copypacket.parameter.checkexpression=Condition for expression evaluation
copypacket.parameter.destinationexpression=Destination expression for Diameter AVP
copypacket.parameter.sourceexpression=Source Expression
copypacket.parameter.defaultvalue=Default Value to be taken for diameter avp
copypacket.parameter.valuemapping=Value Mappings for Copy Packet Mapping
copypacket.inexpression=In Expression 
copypacket.mappingname=Mapping Name for CopyPacket  Operation
copypacket.name=Copy Packet Mapping Configuration Name
copypacket.description=Description
copypacket.script=Groovy Script file path
copypacket.totype=Copy Packet Mapping Translation To type.\
<br /> Translator To Type : Diameter
copypacket.fromtype=Copy Packet Translation Mapping from type.\
<br /> Translator From Type : Diameter
copypacket.dummyesponseparameters.outfield = Copy Packet Maping Dummy Response Parameter Attribute
copypacket.dummyesponseparameters.value = Copy Packet Mapping Dummy Response Parmeter Attribute Value 


#Dynamic Elements in Copy Packet Mapping
copypacket.operation=Operation Details
copypacket.checkexpression=Check Expression Details
copypacket.destinationexpression=Destination Expression Details
copypacket.sourceexpression=Source Expression Details
copypacket.defaultvalue=Default Value Details
copypacket.valuemapping=Value Mapping Details

#Priority Table
prioritytable.applicationid=Application Id  for priority table.<br/> Multiple Application Id can be seperated by (,) or(;) <br/> Example : 16777220,16777216. 
prioritytable.commandcode=Command Code to be specified for priority table. <br/> Multiple Command codes can be seperated by (;) or (,)\
<br/> Example: 272,271
prioritytable.ipaddress=IP Address. Multiple IP addresses can be defined by (,) seperated. Host name,masking and range support is also provided.\
<br/>Example : 10.106.1.158,10.106.1.89,gx.elitecore.com\
<br/>\t Masking Support : 10.106.1.1/23\
<br/>\t Range Support : 10.106.1.1-10.106.1.5
prioritytable.newsession=Diameter New Session. Value can be\
<br /> All - To configure priority for all diameter session.\
<br /> New Session - Defined priority will be applicable for New Sessions.\ <br /> Existing Session - Defined Priority Applicable for existing session.
prioritytable.priority=Priority can be High, Medium or Low. Based on priority,execution performed.

#Diameter Session Management
diameter.sessionmanager.dbscanInterval=DB Scan Interval(ms)
diameter.sessionmanager.dbquerytimeout=DB Query Timeout
diameter.sessionmanager.multivaluedelimeter=Multivalue Delimeter
diameter.sessionmanager.dbfailureaction=This parameter specifies value for action to be perform on database failure that are as following:<br><br>\
1 - Ignore - It means session manager neither perform concurrency check nor rejecting customer on authentication request.In Accounting request, it means session manager will not generate failure event for unsuccessful operation in insert/update/delete operation.<br><br>\
2 - Reject - For Authentication request, it means session manger will reject the customer concurrency check as Database is not available. For Accounting request, it means session manager will drop the customer request as database is not available. <br><br>\
3 - Drop  - For Authentication and Accounting request,  it means session manager will drop the request if database is not available.<br><br>\

diameter.sessionmanager.batchmode=Batch Mode
diameter.sessionmanager.batchmodeenabled=Enabled
diameter.sessionmanager.batchsize=Batch Size
diameter.sessionmanager.batchinterval=Batch Interval(sec)
diameter.sessionmanager.batchquerytimeout=Batch Query Timeout(ms)
diameter.sessionmanager.batchoperation=Batch Operations
diameter.sessionmanager.batchinsert=Insert
diameter.sessionmanager.batchupdate=Update
diameter.sessionmanager.batchdelete=Delete
diameter.sessionmanager.dbfieldname=DB Field Name
diameter.sessionmanager.refereingattribute=Referring Attribute
diameter.sessionmanager.datatype=Data Type
diameter.sessionmanager.defaultvalue=Default Value
diameter.sessionmanager.dbfieldmappingname=Mapping Name
diameter.sessionmanager.lastupdatetimefield=Last Update Time Field
diameter.sessionmanager.starttimefield=Start Time Field
diameter.sessionmanager.sequencename=Sequence Name
diameter.sessionmanager.scenario=Scenario Mappings
diameter.sessionmanager.scenario.ruleset=Ruleset
diameter.sessionmanager.scenario.criteria=Criteria
diameter.sessionmanager.scenario.mappings=Mappings
diameter.sessionmanager.sessionoverideaction=Session Override Action
diameter.sessionmanager.fields=Fields
diameter.sessionmanager.sessionoverideaction.action=Action
diameter.sessionmanager.scenario.name=Name
diameter.sessionmanager.scenario.description=Description
diameter.sessionmanager.session.name=Name
diameter.sessionmanager.session.description=Description

#NAS Service policy
servicepolicy.naspolicy.responseattributes=Response Attributes
servicepolicy.naspolicy.commandcode=Command Code
servicepolicy.naspolicy.responseattribute=Response Attribute
<br /> Translator From Type : Diameter


servicepolicy.proxypolicy.script=Script
servicepolicy.proxypolicy.acceptontimeout=Accept On Timeout
servicepolicy.proxypolicy.waitforResponse=Wait for Response
servicepolicy.proxypolicy.plugin.onrequest=On Request
servicepolicy.proxypolicy.plugin.onresponse=On Response
servicepolicy.proxypolicy.server=Server/group
servicepolicy.proxypolicy.translationmapping=Translation Mappings
servicepolicy.proxypolicy.primarygroup=Primary Group
servicepolicy.proxypolicy.secondarygroup=Secondary Group
servicepolicy.additionalgroup=Additional Group
servicepolicy.authpolicy.radiuspolicy=Radius Service Policy
servicepolicy.proxypolicy.accountingdriver=Accounting Driver
servicepolicy.proxypolicy.drivergroup=Driver Group
servicepolicy.proxypolicy.driverscript=Driver Script
servicepolicy.proxypolicy.radiusmessages= This configuration contains two check box.<br/><br/> 1) Authentication Message <br/> 2) Accounting Message. 
servicepolicy.proxypolicy.primarydriver=Primary Driver
servicepolicy.proxypolicy.secondarydriver=Secondary Driver
servicepolicy.proxypolicy.driverscript=Driver Script
servicepolicy.proxypolicy.waitforcdrdump=Driver Script
servicepolicy.proxypolicy.defaultauthresponsebehavior=Default Authentication Response Behavior
servicepolicy.proxypolicy.defaultacctresponsebehavior=Default Accounting Response Behavior
copypacket.title=Title desc
servicepolicy.naspolicy.commandcode= This parameter refers to Command Code for which the Additional Attributes are to be added in Response Packet. \
Multiple comma-separated Command codes can be configured. <br /> \
<b>Possible values: </b> Any valid command code <br /> <b>Example:</b> 271 
servicepolicy.naspolicy.responseattribute= This parameter refers to the Additional Attributes \
that should be added in the Response Packet. Multiple comma-separated attributes can be configured. \
<br /> <b>Possible Values: </b> Any valid Attribute-Id Value pair <br /> <b>Example:</b> 0:274 = 1

#Change Password
changepwd.username=User Name 
changepwd.currentpassword=Current Password of the user
changepwd.newpassword=New Password of the user
changepwd.confirmnewpassword=Confirm New Password

#Nas Service Policy
naspolicy.name=Name

#Radius Service Policy
radiusservicepolicy.basic.ruleset=Authentication Rule-Set contains criteria of Authentication service flow. If authentication ruleset is matched with authentication request, then Radius Service Policy will execute the Authentication service flow for satisfied request. 
radiusservicepolicy.basic.acctruleset=Accounting contains criteria of Accounting service flow. If Accounting rule-set is mated with accounting request, then Radius service policy will execute the Accounting service flow for satisfied request. 
acctpolicy.ruleset=This parameter facilitates you in configuring a check expression which will be applied on the incoming accounting request packet.<br><br>\
If this condition is successfully satisfied by the received accounting request, then this policy will be selected for being applied on the received request.<br/><br/>
radiusservicepolicy.useridentity=This parameter is used to configure the attribute based on which the user, for which authentication is to be performed, is identified. Out of all the user profiles stored in the database/file, the Authentication Service has to identify the user for which the Authentication Request is received. It does this with the help of the attribute id set in <b>User Identity Attribute</b> parameter of Authentication Service.<br>\
<br/>You can configure multiple attributes in this field, for profile identification. You can also configure nested attributes and Vendor Specific Attributes in this field. For multiple attribute configuration, EliteRadius will lookup for attributes in sequence. If an attribute is found in the request packet (as per the sequence), then it will ignore rest configured attributes.
radiusservicepolicy.validatepacket=Validate Packet contains two values 1) True 2) False.<br/><br/> <b>Default value : </b> False.<br/><br/> If it is true, then Radius Service policy validate the Authentication packet as per RFC-2865 and validate the Accounting packet as per RFC-2866. 
servicepolicy.proxypolicy.defaultauthresponsebehavior= It is a drop-down box with three values <br/><br/> 1) Reject(Default) <br/>2) Drop <br/>3) Hotline. <br/><br/> If configured ESI(Drivers, Radius ESI) is not alive(Down), then Radius Service policy will apply the configured behavior for Authentication packets. 
servicepolicy.proxypolicy.defaultacctresponsebehavior= It is a drop-down box with two values <br/><br/> 1) Drop(default) <br/> 2) Response.<br/><br/> If configured ESI(Drivers,Radius ESI) is not alive(Down), then Radius service policy will apply the configured behavior for Accounting packets. 
servicepolicy.authpolicy.hotlinepolicy=This textbox contains a hotline-policy name for Default Authentication response behavior. <br/><br/>This textbox will be enabled only if Hotline option is selected in Default Authentication response behavior. 
servicepolicy.authpolicy.resattrs=It contains comma separated list of AVPs for Authentication packets. <br/><br/>Response Attribute will be added into packets only if configured AVP is not present into response packets. 
servicepolicy.authpolicy.cui=&quot;CUI&quot; is an abbreviation for <b>Change Of Authorization</b>. It specifies an alias for the subscriber identity, while routing RADIUS packet through the network. <br><br>\
This parameter is used only in the response packet with respect to CUI attribute received in the incoming access request packet.  <br>\<br>\
Depending on configuration, CUI can be Authenticated-Identity, value for GROUPNAME, or value given here (into CUI)
servicepolicy.authpolicy.cuiresattrs=CUI Response Attributes
servicepolicy.proxypolicy.sessionmanager=This drop-down box  contains list of Session managers. <br/><br/> The configured session-manager will apply on both Authentication and Accounting packets.<br><br>This to be used to manage the user sessions.<br>\<br>
radiusservicepolicy.cui=Accounting CUI Attribute
radiusservicepolicy.advancedcuiexpression=Advanced CUI Expression
radiusservicepolicy.prepluginlist=The key that has been configured in the Transaction Logger Plugin should be specified in the Argument. The operation specified in the Key will get applied on the packet.
radiusservicepolicy.cdrgen.primarydriver=This parameter specifies the driver that has to be used to dump data in database on received request. 
radiusservicepolicy.postpluginlist=Specifies a list of post-plugins.<br><br>\
If any of the Post-Auth-Plugin is configured, then the received authentication request is forwarded to the configured plugin, after the main authentication process is over.<br>\<br>\
After the plugin application, the response packet will be sent to the client, if it qualifies.
update.user.identity=This feature does not modify the subscriber identity into request packet. It first fetch the identity from the request packet, then perform the update identity operation on it. On the resultant value, Profile lookup driver tries to fetch the customer profile from the Authentication driver. This feature supports following sub parameters <br><br>\
<b>1)Strip Identity    : </b>This drop-down has 3 possible values. a) Node b) Prefix c) Suffix. This parameter indicate that whether Profile Lookup driver will strip the identity value before fetching the customer profile or not. If yes then two possible values are available. 1) Prefix 2) Suffix. On strip the identity by any separator, there will be two values. Which part will be considered as a User-Identity, that decision is taken by Prefix or Suffix configuration. <br><br>\
<b>2) Separator        : </b>If Strip identity is enabled, means Prefix or Suffix is selected, only then this parameter will be enabled. Based on this character/symbol, User identity will be stripped. <br><br>\
<b> 3) Select Case       : </b> Select Case is case conversion of user&#45;identity. This parameter is used for case insensitive feature of subscriber identity. Means, if subscriber profile is provision in small case, and request contains Upper&#47;Proper case identity. Profile Lookup handler reject the customer with &#34;User not found&#34; . As by default subscriber identity is case sensitive. If Upper Case&#47;Lower case is selected from the drop-down then before fetching the subscriber profile, Profile Lookup Handler will convert the identity to Upper Case&#47;Lower case &#40;based on selection&#41; then fetch the subscriber profile. <br><br>\
<b> 4) Trim User-Identity: </b> In C language, All literal are closed or trailed with (null) character. As per RFC&#45;2865, AAA should truncate the null character. For enabling this feature we need to enable the trim User&#45;Identity feature. <br><br><b> 5) Trim User-Password: </b> It is a checkbox. In C language, All literal contains (null) character at the end of literals. As per RFC-2865, AAA should truncate the null character, For enabling this feature we need to enable the trim User-Password feature. 
servicepolicy.authpolicy.anonymousidentity=This feature is called Anonymous login into Service profile network. <br><br>When any subscriber roams into service provider network, and service providers want that unknown subscriber connect to network with restricted policy for advertisement purpose or to sell/purchase new package as per business need. <br><br>This anonymous identity MUST be provision in either Primary or Secondary driver.
servicepolicy.proxypolicy.primarygroup=This parameter specifies the driver group that is to be used to fetch the user profile from the AAA database on receipt of an authentication request. <br><br>\
----------------------------------------------------------------------------------------------------------------------<br><br>\
Here, W represents the no. of requests that should be served by the driver. <br/><br/>
servicepolicy.proxypolicy.secondarygroup=This parameter specifies the driver group that is to be used as a fallback driver in case the drivers mentioned in the primary group fails to authenticate the user. 
servicepolicy.additionalgroup=With multiple additional driver split profile concept can be achieved. Weight-age is not applicable for Additional driver in this group.<br><br> The same authentication driver of Primary group cannot be a part of Additional Group. But the same authentication driver of Secondary group can be a part of Additional Group.
servicepolicy.acctpolicy.driverscript=Groovy name can be specified at this level. This is a common script for all Primary, Secondary and Additional drivers. This groovy is used for customization in customer profile as per call-flow/business need. 
servicepolicy.authpolicy.authmethods=This parameter has 4 options(checkbox). <br><br>1) PAP <br>2) CHAP <br>3) EAP <br>4) Digest. <br><br>This parameter specifies that selected Authentication method is supported by this service flow.<br><br> These checkboxes are multi-select checkbox. i.e. Admin can select PAP, CHAP and EAP simultaneously. At least one Authentication Method(checkbox) should be selected.
servicepolicy.authpolicy.digestconfig=This parameter contains a dropdown with list of Digest configuration.<br><br> This parameter is by default<b> disabled</b>. <br><br>When Digest Authentication is enabled, then this parameter should be enabled, This parameter selected Digest configuration based on that Digest Authentication takes place. 
servicepolicy.authpolicy.eapconfig= This parameter contains a dropdown with list of EAP configuration. This parameter is by default disabled. When EAP Authentication is enabled, then this parameter should be enabled. This parameter selects the EAP Configuration based on that EAP Authentication takes place. <br><br>\
The access path for creating EAP configuration is as below:<br>\<br>\
<b>Servers -> EAP config -> create EAP Config</b> 
servicepolicy.authpolicy.username=This parameter refers to the attribute based on which the user authentication is to be performed. Out of all the subscriber profiles stored in the authentication database/file, the Authentication Service has to identify the subscriber for which the Authentication Request is received. It does this with the help of the attribute-name set in &quot;User Name&quot; configuration of Authentication Service. <br>\<br>\ 
servicepolicy.authpolicy.usernameresattrs=This parameter specifies the username attributes received in the Access request packet.
servicepolicy.authpolicy.wimaxenabled=This parameter specifies whether Wimax services should be enabled or not.<br>\<br>\
 ->If this attribute is set to <b>TRUE</b>, then Wimax services will be enabled. <br/><br/>->If set to <b>FALSE</b>, then any request received from a Wimax client will not be processed and an Access-Reject will be sent to that client.
servicepolicy.authpolicy.threegppenabled=This parameter specifies whether 3GPP service should be enabled or not.<br>\ <br>\ ->If this attribute is set to <b>TRUE</b>, then 3GPP processing will be supported. <br/><br/>->If set to <b>FALSE</b>, then any request received from a 3GPP client will not be processed and an Access-Reject will be sent to that client.
servicepolicy.authpolicy.defaultsessiontimeout=The possible values are -1, 0 and >0.Specified value should in seconds. Means if Administrator want to configure 10 minutes then value will be 600. Same way Administrator wants to configure 24 hours, then value will be 86400. Default value of session-timeout will be 86400. 
servicepolicy.authpolicy.radiuspolicy=This parameter contains three checkboxes with values 1) Reject on Check item not found 2) Reject on reject item not found 3) Accept on policy not found. This parameter is used while applying Authorization policy and Client policy. Default all the parameter should be unchecked. <br><br>\
<b>Reject On Check Item Not Found : </b>On the basis of this parameter the system decides whether the authentication request should be rejected or forwarded for further processing, if the Attribute Id, configured in the check item of the service policy, is not found in the request packet. <br>\
<br/><b>Reject On Reject Item Not Found : </b>On the basis of this parameter the system decides whether the authentication request should be rejected or forwarded for further processing, if the Attribute Id, configured in the reject item of the service policy, is not found in the request packet.<br>\
<br/><b>Accept On Policy Not Found : </b>Policies are configured in the user profile. Now it is possible that inspite of configuring the policy for the user, it is not found due to caching issues. In such a scenario, this parameter comes into picture.<br><br>\
-> If you have the set this parameter as Accept</b>, then the EliteAAA server continues processing the request and if you have set the parameter as <b>Reject</b>, then the request will be rejected.
servicepolicy.authpolicy.gracepolicy= This parameter is a drop-down with list of grace policy. <br><br>When customer account is expired and customer tries to login into network, Grace Policy is applied.<br><br> If Grace Policy is satisfied then customer can login into system. Grace policy can be defined in customer profile. But if business need a grace policy service wise, based on that Administrator can configure the grace policy in this parameter. 
servicepolicy.proxycommunication.configuremore=
radiusservicepolicy.proxycommunication.ruleset=This is a specific condition for individual entry of Proxy communication Handler.<br><br> If it is blank then, Proxy Communication handler will always send request to configured ESI. <br><br>If expression is specified in Rule-Set then Proxy Communication handler will check for the condition and if condition is satisfied then Proxy communication handler will proxy the request to specified system. 
radiusservicepolicy.proxycommunication.servergroup= Server Group is an inner table in Proxy Communication Handler.<br><br> Every entry consist one Server Group.<br><br> The purpose of the Server-Group is to achieve external system communication functionality such as Load Balancing, Primary/Secondary System (Failover).Multiple entries are allowed in Server-Group table. This table contains three columns as below.  <br><br>\
<b> a) Server Name:</b>It is a drop-down consist of all type of Radius External system. One Server group can contains only one type of Radius External System. i.e. Prepaid Server and IP Pool Radius Type cannot be in a same group.<br><br>\
<b> b) Load Factor:</b>It is a drop-down consist of pre-defined load factor. It consist a value from 0 to 10. Default value will be 1. If 0 then defined then configured Server name acts as a Secondary (Failover) system in a Server-Group. There could not be multiple Secondary systems in on Server-Group.<br><br>\
<b> c) Remove:</b>It is a remove button for deleting Server Entry from Server-Group. 
radiusservicepolicy.proxycommunication.translationmapping= It is a drop down box which contains list of translation mapping as well as list of copy packet mappings. <br><br>\
The listed translation mapping is of <b> Radius to Radius type only.</b><br><br>\
The selected translation mapping will be applied on all selected Servers in this Proxy Communication Handler entry. <br><br>\
The translation mapping will be applied on Request and Response.<br>\<br>\
The access path for creating Translation Mapping Config and Copy Packet Config is as below:<br>\<br>\
<b> Translation Mapping Config: </b><br>\
=====================================================<br>\
Servers -> Translation Mapping Config -> Create Translation Mapping Config <br>\<br>\
<b> Copy Packet Mapping Config: </b><br>\
=====================================================<br>\
Servers -> Copy Packet Mapping Config-> Create Copy Packet Mapping Config
radiusservicepolicy.proxycommunication.script= It is a textbox which contains a groovy script name.<br><br>\ The configured groovy will be applied on all selected servers in this Proxy communication handler.<br><br>\ The groovy will be applied on Request and Response packet. 
radiusservicepolicy.proxycommunication.acceptontimeout= It is a checkbox which indicates whether to consider success on timeout or not.<br><br>\ If this configuration is enabled then on request timeout, Proxy Communication Handler will mark the request as Access-Accept. <br><br>\If this configuration is disabled then on request timeout, Proxy Communication handler will mark the request as Access-Reject (Failure).
radiusservicepolicy.cdrgen.ruleset=This is a specific condition for individual entry of CDR Handler.<br><br> If it is blank then, CDR handler will always send request to configured Driver. <br><br>If expression is specified in Rule-Set then CDR handler will check for the condition is satisfied then configured handler will be applied.
radiusservicepolicy.cdrgen.primarydriver=This parameter specifies the driver that has to be used to dump data in database on received request. 
radiusservicepolicy.cdrgen.secondarydriver=This parameter specifies the driver that has to be used to dump data in database as a fail over driver in case the drivers mentioned in the primary fails to dump the CDR files.
radiusservicepolicy.cdrgen.driverscript=It contains a groovy script name. <br><br>\ The configured groovy will be applied on selected driver in this CDR handler.<br><br>\ The groovy will be applied on Request and Response packet. 
radiusservicepolicy.cdrgen.waitforcdrdump=If it is configured then it will wait for CDR dump. 
radiusservicepolicy.cdrgen.configuremore=Add more driver entries
radiusservicepolicy.servicehandlerlist=Service Handler List
radiuspostservicepolicy.servicehandlerlist=<b> CDR Handler: </b><br>\====================================================================<br>\CDR Handler is used to dump CDR in files or database.<br>\<br>\
<b> COA/DM Handler: </b><br>\====================================================================<br>\COA/DM Handler is used to make COA/DM request whenever there is a change in authorization.<br>\<br>\
<b> Plugin Handler: </b><br>\====================================================================<br>\Plugin Handler is used to customized the service flow of request or response in service policy.
radiusservicepolicy.sessionmanager=This parameter specifies the name of the Session Manager,This session manager will used for session management<br>\<br>\
The Access path for creating a Session Manager is:<br>\<br>\
<b>Servers -> Session Manager -> Create Session Manager</b>

tgppaaaservicepolicy.Diameterconcurrencypolicy=This parameter specifies the name of the Diameter Concurrency Policy,This Diameter Concurrency Policy will used for Concurrency<br>\<br>\
The Access path for creating a Diameter Concurrency Policy is:<br>\<br>\
<b>Diameter -> Diameter Concurrency Policy -> Create Diameter Concurrency Policy</b>

radiusservicepolicy.addbroadcastingcommunication=Add Broadcasting Communication
radiusservicepolicy.coadmgeneration.ruleset=Ruleset
#radiusservicepolicy.proxycommunication.translationmapping=Translation mapping & Copy Packet Mapping
#radiusservicepolicy.proxycommunication.script=Script
#radiusservicepolicy.proxycommunication.acceptontimeout=Accept on timeout
radiusservicepolicy.proxycommunication.waitforresponse=Wait for Response
radiusservicepolicy.addplugin=Add Plugin
radiusservicepolicy.plugin.ruleset=This ruleset contains an expression.<br><br> This is a specific condition for individual entry of Plugin Handler. <br><br>If it is blank then, Plugin handler will always send request to configured plugin.<br><br> If expression is specified in Rule-Set then Plugin handler will check for the condition and if condition is satisfied then configured plugin will be applied.
radiusservicepolicy.plugin.plugin=If any of the Plugin is configured, then the received request or response will be forwarded to that plugin first.<br>\<br>
radiusservicepolicy.plugin.responsetype=If it configured as request then the request can be forward for main processing, if it qualifies.<br><br>\If it configured as response then the response packet will be sent to the client, if it qualifies.
radiusservicepolicy.plugin.pluginarguments=The key that has been configured in the Transaction Logger Plugin should be specified in the argument. The operation specified in the key will get applied on the packet.
radiusservicepolicy.authpolicy.ruleset=Ruleset
radiusservicepolicy.coadmgeneration.scheduleafter=This parameter specify the duration in milliseconds after which the CoA/DM request should be generated. 
radiusservicepolicy.coadmgeneration.ruleset=The rule set contains the condition that will be checked on the request to decide whether to filter the respective entry or not. 
radiusservicepolicy.coadmgeneration.packettype= It is a drop-down consist of Packet Type i.e. CoA request and Disconnect Message. Packet Type specifies the type of the packet of the request generated 
radiusservicepolicy.coadmgeneration.translationmapping= It is a drop-down box which contains list of translation mapping as well as list of copy packet mappings. <br><br>\
The access path for creating Translation Mapping Config and Copy Packet Config is as below:<br>\<br>\
<b> Translation Mapping Config: </b><br>\
=====================================================<br>\
Servers -> Translation Mapping Config -> Create Translation Mapping Config <br>\<br>\
<b> Copy Packet Mapping Config: </b><br>\
=====================================================<br>\
Servers -> Copy Packet Mapping Config-> Create Copy Packet Mapping Config
radiusservicepolicy.addattributemapping=Add Attribute Mapping
radiusservicepolicy.acct.preplugin=Specifies a list of pre-plugins.<br>\<br>\If any of the Pre-Acct Plugin is configured, then the received accounting request will be forwarded to the plugin first.<br>\<br>\
After plugin application, the request can be forward for main processing, if it qualifies.
radiusservicepolicy.acct.postplugin=Specifies a list of post-plugins.<br>\<br>\If any of the Post-Acct-Plugin is configured, then the received accounting request is forwarded to the configured plugin, after the main authentication process is over.<br>\<br>\
After the plugin application, the response packet will be sent to the client, if it qualifies.
radiusservicepolicy.broadcastcommunication.ruleset= This ruleset contains an expression.<br><br> This is a specific condition for individual entry of Broadcasting communication Handler. <br><br>If it is blank then, Broadcasting Communication handler will always send request to configured ESI.<br><br> If expression is specified in Rule-Set then Broadcasting Communication handler will check for the condition and if condition is satisfied then Broadcasting communication handler will proxy the request to specified system. 
radiusservicepolicy.broadcastcommunication.servergroup= Server Group is an inner table in Broadcasting Communication Handler.<br><br> Every entry consist one Server Group. <br><br>The <b> purpose </b> of the Server-Group is to achieve external system communication functionality such as Load Balancing, Primary/Secondary System (Failover).Multiple entries are allowed in Server-Group table. <br><br>This table contains three columns as below:<br><br>\
<b>a) Server Name:</b> It is a drop-down consist of all type of Radius External system. One Server group can contains only one type of Radius External System. i.e. Prepaid Server and IP Pool Radius Type cannot be in a same group.<br><br>\
<b>b) Load Factor:</b> It is a drop-down consist of pre-defined load factor. It consist a value from 0 to 10. Default value will be 1. If 0 then defined then configured Server name acts as a Secondary (Failover) system in a Server-Group. There could not be multiple Secondary systems in on Server-Group.<br><br>\
<b>c) Remove:</b> It is a remove button for deleting Server Entry from Server-Group. 
radiusservicepolicy.broadcastcommunication.translationmapping= It is a drop-down box which contains list of translation mapping as well as list of copy packet mappings.<br><br> The listed translation mapping is of <b>Radius to Radius type only.</b> <br><br> The selected translation mapping will be applied on all selected Servers in this Broadcasting Communication Handler entry. <br><br>The translation mapping will be applied on Request and Response. <br><br>\
The access path for creating Translation Mapping Config and Copy Packet Config is as below:<br>\<br>\
<b> Translation Mapping Config: </b><br>\
=====================================================<br>\
Servers -> Translation Mapping Config -> Create Translation Mapping Config <br>\<br>\
<b> Copy Packet Mapping Config: </b><br>\
=====================================================<br>\
Servers -> Copy Packet Mapping Config-> Create Copy Packet Mapping Config
radiusservicepolicy.broadcastcommunication.script= It contains a groovy script name. <br><br>\ The configured groovy will be applied on all selected servers in this Broadcasting communication handler.<br><br>\ The groovy will be applied on Request and Response packet. 
radiusservicepolicy.broadcastcommunication.acceptontimeout= It indicates whether to consider success on timeout or not. <br><br>If this configuration is enabled then on request timeout, Broadcasting Communication Handler will mark the request as Access-Accept.<br><br> If this configuration is disabled then on request timeout, Broadcasting Communication handler will mark the request as Access-Reject (Failure). 
radiusservicepolicy.broadcastcommunication.waitforresponse= It indicates whether to wait for the response or not. <br><br>If this configuration is enabled then after proxies the request Broadcasting handler will wait for the response and once response received it accumulate the response into original response packet.<br><br> If this configuration is disabled then after proxies the request Broadcasting handler will not wait for the response or if response received Broadcasting handler will ignore the response as configuration is disabled.
radiusservicepolicy.advancedusernameexpression=Advanced Username Expression

#Main description for radius service policy
radiusservicepolicy.authpreplugin.maindetails=pre plugin 
radiusservicepolicy.authserviceflow.maindetails=Service Flow
radiusservicepolicy.authpostplugin.maindetails=Post Plugin
radiusservicepolicy.authpostresponseservice.maindetails=Post Response Processing will be executed after sending response. Post Response Processing is not a part of service execution but it is additional processing which is required after sending response.

#Accounting
radiusservicepolicy.acctpreplugin.maindetails=Pre plugin
radiusservicepolicy.acctserviceflow.maindetails=Service Flow
radiusservicepolicy.acctpostplugin.maindetails=Post Plugin
radiusservicepolicy.acctpostresponseservice.maindetails=Post Response Processing will be executed after sending response. Post Response Processing is not a part of service execution but it is additional processing which is required after sending response.

#All handler - Main contents
radiusservicepolicy.profilelookupdriver.maincontent=Profile Lookup Handler
radiusservicepolicy.authenticationhandler.maincontent=Authentication Handler
radiusservicepolicy.authorizationhandler.maincontent=Authorization Handler
radiusservicepolicy.cdrhandler.maincontent=Authorization Handler
radiusservicepolicy.concurrencyhandler.maincontent=Concurrency Handler
radiusservicepolicy.proxycommunication.maincontent=Proxy Communication handler
radiusservicepolicy.broadcatcommunication.maincontent=BroadcastCommunication handler
radiusservicepolicy.pluginhandler.maincontent=Plugin Handler
radiusservicepolicy.coadmhandler.maincontent=CoA/DM handler
radiusservicepolicy.sessionmanager.ruleset=It is a textbox which contains an expression.<br><br>\ The rule set contains the condition that will be checked on the request to decide whether to filter the respective entry or not 

imsibasedroutingtable.routingtablename=Routing Table Name
imsibasedroutingtable.imsiidentityattribute=IMSI Identity Attribute
routingconf.imsibasedrouting.imsirange=IMSI Prefix
routingconf.imsibasedrouting.primarypeer=Primary Peer
routingconf.imsibasedrouting.secondarypeer=Secondary Peer
routingconf.imsibasedrouting.export=Export
routingconf.imsibasedrouting.import=Import
imsibasedroutingtable.forentries=IMSI Based Routing Table
routingconf.imsibasedrouting.tag=Tag

#MSISDN Based Routing Table
msisdnbasedroutingtable.tablename=Routing Table Name
msisdnbasedroutingtable.list=Existing MSISDN Based Routing Tables
msisdnbasedroutingtable.msisdnidentityattributes=MSISDN Identity Attribute
msisdnbasedroutingtable.msisdnlength=MSISDN Length
msisdnbasedroutingtable.mcc=MCC
msisdnbasedroutingtable.addnewentries=Add New Entries
msisdnbasedroutingtable.msisdnrange=MSISDN Prefix
msisdnbasedroutingtable.primarypeer=Primary Peer
msisdnbasedroutingtable.secondarypeer=Secondary Peer
msisdnbasedroutingtable.tag=Tag
msisdnbasedroutingtable.routingentries=MSISDN Based Routing Entries
msisdnbasedroutingtable.export=Export CSV
msisdnbasedroutingtable.import=Import CSV

diameterrouting.subscriber.routing1=Subscriber Routing 1
diameterrouting.subscriber.routing2=Subscriber Routing 2

#Radius Policy Group
radiuspolicy.radiuspolicygroup.name=Name of the policy used in subscriber profile to specify Policy Group.
radiuspolicy.radiuspolicygroup.expression=Expression contains the logical expression of the Policies.

#Diameter Policy Group
diameterpolicy.diameterpolicygroup.name=Name of the policy used in subscriber profile to specify Policy Group.
diameterpolicy.diameterpolicygroup.expression=Expression contains the logical expression of the Policies.

#Diameter Concurrency
diameter.diameterconcurrency.name=Name of Diameter Concurrency
diameter.diameterconcurrency.description=Description
diameter.diameterconcurrency.datasource=Data Source
diameter.diameterconcurrency.starttime=Start Time
diameter.diameterconcurrency.tablename=Table Name
diameter.diameterconcurrency.lastupdatetime=Last Update Time
diameter.diameterconcurrency.dbfailureaction=DB Failure Action
diameter.diameterconcurrency.delimeter=Delimeter
diameter.diameterconcurrency.sessionoverideproperties=Session Override Action
diameter.diameterconcurrency.action=Action
diameter.diameterconcurrency.fields=Fields
diameter.diameterconcurrency.dbfieldname=DB Field Name
diameter.diameterconurrency.referringattribute=Referring Attribute
diameter.diameterconcurrency.datatype=Data Type
diameter.diameterconcurrency.defaultvalue=Default Value
diameter.diameterconcurrency.includeinasr=Include In ASR
diameter.diameterconcurrency.concurrencyidentityfield=Concurrency Identity Field
diameter.sessionmanager.searchactivesessionfields=Search Columns
diameter.searchasm.searchcolumnname= Specifies Column name that you want to search.Comma seperated values are allowed.

#Subscriber Routing Table
subscriberroutingtable.searchsubscriber=Search Subscriber

#Plugin
plugin.name=Specify the name of plugin
plugin.name=Instance Name
plugin.plugintype=Plugin Type
plugin.description=Description
radiusservicepolicy.pluginname=Plugin Name
radiusservicepolicy.pluginArg=Plugin Argument


#Transaction Logger
plugin.transactionlogger.timebasedrollingunit=Time Based Rolling Unit
plugin.transactionlogger.logfile=Log File
plugin.transactionlogger.formatmappings=Format Mappings
plugin.transactionlogger.formatmappings.key=Key
plugin.transactionlogger.formatmappings.format=Format
plugin.transactionlogger.formatmappings.remove=Remove
plugin.transactionlogger.timeboundry=Represents amount of time after which logging file is rolled. Works same as <b>Time Boundry</b> rolling unit of <b>CDR Driver</b>
plugin.transactionlogger.logfile=Absolute or Relative path with file name and extension
plugin.transactionlogger.sequencerange=This parameter specifies the range for sequencing the log files.<br><br>Sequence range can be provided in [ ] (square brackets) <br><br><b>Sample value:  [1-1000] or [a-z]. </b> <br><br> Where, 1 is the start value and 1000 is the end value. <br> So, the log files will be sequenced starting from 1 or a.
plugin.transactionlogger.pattern=This parameter specifies whether to add the sequence range as a prefix or suffix, to the log file name.<br><br><b>Possible Values:</b><br> 1.Suffix <br> 2.Prefix
plugin.transactionlogger.globalization=If this parameter is set to true, then all the generated logs will be dumped in different directory (ies) as per the continuous sequencing of the logs, i.e. the sequence number of logs will be in sync irrespective of different directories.<br><br> If set to false, then the logs dumped in different directories will follow different sequence numbers i.e. each directory will have a separate set of sequence numbers beginning with the start value.
#TGPP AAA Policy
tgppaaapolicy.status=This parameter specifies the status of an TGPP AAA Policy.
tgppaaapolicy.active=Active
tgppaaapolicy.inactive=In Active
tgppaaapolicy.all =All
tgppaaapolicy.name=This parameter specifies the name of TGPP AAA Policy.
tgppaaapolicy.description=This parameter specifies the description of TGPP AAA Policy.
tgppaaapolicy.sessionmanagment=this parameter specifies the Session Management True/false.
tgppservicepolicy.postservicehandlerlist=<b> CDR Handler: </b><br>\====================================================================<br>\CDR Handler is used to dump CDR in files or database.<br>\<br>\
<b> Plugin Handler: </b><br>\====================================================================<br>\Plugin Handler is used to customized the service flow of request or response in service policy.
tgppservicepolicy.postresponseserviceflow=Post Response Processing will be executed after sending response. Post Response Processing is not a part of service execution but it is additional processing which is required after sending response.
tgppaaapolicy.defaultresponsebehavior= Display a list with three values <br/><br/> 1)<b>REJECT (Current Behaviour) : </b> In this case a desired Result code can be configure. <br/>2)<b><b>DROP (No Response)</b></b> <br/>3) <b> HOTLINE(Hotline purpose) : </b> In this case a user can configure created hotline policy.   <br/><br/>In case when REJECT or HOTLINE is selected at that time a Default Response Behaviour Argument must have value.
tgppaaapolicy.defaultresponsebehaviourargument= This parameter contains a value depends on <b>Default Response Behaviour</b> In case when Reject is configure then it must have a result code and when Hotline is configure then it must have a created hotline policy. 
#TGPP CDR Handler
tgppaaapolicy.cdrhandler.title=CDR Handler
tgppaaapolicy.cdrhandler.ruleset=This is a specific condition for individual entry of CDR Handler.<br><br> If it is blank then, CDR handler will always send request to configured Driver. <br><br>If expression is specified in ruleset then CDR handler will check for the condition
tgppaaapolicy.cdrhandler.primarydriver=This parameter specifies the driver that has to be used to dump data in database on receipt of request.
tgppaaapolicy.cdrhandler.secondarydriver=This parameter specifies the driver that has to be used to dump data in database as a fail over driver in case the drivers mentioned in the primary fails to dump the CDR files.
tgppaaapolicy.cdrhandler.driverscript=Groovy name can be specified at this level. This is a common script for all Primary And Secondary drivers. This groovy is used for customization in customer profile as per call-flow/business need.
tgppaaapolicy.cdrhandler.waitforcdrdump=If it is configured then it will wait for CDR dump.

#Diameter Proxy Sequential Handler
tgppaaapolicy.tgppaaapolicy.resultcode = Enter the result code you want to send when no rule set is satisfied

#Diameter Peer Group
diameterpeergroup.title=Diameter Peer Group
diameterpeergroup.search=Search Diameter Peer Group
diameterpeergroup.list=Diameter Peer Group List
diameterpeergroup.create=Create Diameter Peer Group
diameterpeergroup.name=Peer Group Name
diameterpeergroup.primarypeer=Primary Peer
diameterpeergroup.secondarypeer=Secondary Peer
diameterpeergroup.description=Description
diameterpeergroup.stateful=This parameter specifies stateful true / false .
diameterpeergroup.transactiontimeout=This parameter represents the maximum time for which the group will try to serve or reroute request. If timeout is reached then the peer-group gives up. <br><br>Note: Possible value 0-N (if 0 is configured then this will be disabled). 
diameterpeergroup.peergroup=This parameter specifies the peers-entries for load-balancing. Each peer-entry contains peer-name and weightage(allows only 1-10)
diameterpeergroup.georedunduntgroup= Geo Redundancy feature at Peer group wherein when the primary group/zone goes down then whole traffic is switched to geo redundant group/zone. As soon as any peer in primary group comes back alive, all sessions including the ones attached with geo redundant group, switch back to primary group. 

#Quota Management Plugin
plugin.radius.quotamanagement.title=Quota Management Plugin
plugin.prepaidquotamanager.title=Prepaid Quota Manager List
plugin.prepaidquotamanager.name=Name
plugin.prepaidquotamanager.ruleset=Ruleset
plugin.prepaidquotamanager.prepaidquotatype=Prepaid Quote Type
plugin.prepaidquotamanager.continuefurtherprocesing=Continue Further Processing
plugin.prepaidquotamanager.action=Action
plugin.prepaidquotamanager.typeofpacket=Type Of Packet
plugin.prepaidquotamanager.classattributekeyforvolume=Class Attribute Key For Volume
plugin.prepaidquotamanager.classattributekeyfortime=Class Attribute Key For Time
plugin.prepaidquotamanager.listofattributes=List of Attributes

#User Statistic Post Auth Plugin
plugin.radius.userstatisticpostauth.title=User Statistic Post Auth Plugin
plugin.userstatisticpostauth.title=User Statistic Post Auth Plugin List
plugin.userstatisticpostauth.subtitle=User Statistic Post Auth Plugin
plugin.userstatisticpostauth.datasourcename=This parameter holds the data source name by which the database is identified. <br>\<br>\.
plugin.userstatisticpostauth.tablename=This parameter refers to the Table Name which will be used for retrieving the DB Field. </br></br> <b>Default value</b> : TBLUSERSTATISTICS.
plugin.userstatisticpostauth.dbquerytimeout=This parameter specifies the duration after which, if the database does not respond to a query, the Server Manager should consider the &quot;query timeout&quot; event to have occurred.<br>\<br>\ The value for this parameter can be determined in terms of milliseconds.
plugin.userstatisticpostauth.maxquerytimeoutcount=&quot;Max Query Timeout Count&quot; parameter value refers to the maximum count of consecutive &quot;query timeout&quot; occurrence after which the Server Manager should mark the database as &quot;dead&quot;. <br><br>\\The database marked as &quot;dead&quot; will be marked &quot;live&quot; once it is up and running.
plugin.userstatisticpostauth.batchupdateinterval=The &quot;Batch Update Interval&quot; parameter refers to the time interval after which the scheduler runs for each batch processing. <br><br>\ <b>Default Value: </b> 1000 ms, i.e. the scheduler will run after every 1000 ms.

plugin.userstatisticpostauth.mapping.title=DB Field Mapping
plugin.userstatisticpostauth.attributeid=Specifies which attributes are to be dumed from Request Packet or Response Packet.
plugin.userstatisticpostauth.packettype= It is a drop-down consist of Packet Type i.e. Request Packet and Response Packet. Based on selected packet type attribute value will be dumped in database.
plugin.userstatisticpostauth.dbfield=This parameter refers to the DB field attribute that is to be used for mapping.
plugin.userstatisticpostauth.datatype=Data Type attribute refers to the data type of the field which you are mapping with the Database. This data type could be either string or date.
plugin.userstatisticpostauth.defaultvalue=It might happen sometimes that a particular attribute, in the request packet or response packet is missing or its value is missing. Under such circumstances, the EliteAAA Server puts the value that you have specified in the Default Value parameter in Attribute section of the attribute, under consideration.
plugin.userstatisticpostauth.usedictionaryvalue=If Use Dictionary Value parameter is set to True then not the integer value in the request, but the corresponding understandable string from the Dictionary will be dumped in database.<br><br>\If set to False, the same integer, received in the request is dumped in database.

#Diameter peer-profile
diameterpeerprofile.hotlinepolicy=This parameter specifies the Hotline-policy name for Diameter Peer-Profile.


#EliteCSM Default Configuration QuickSetup
setup.username = Username
setup.password = Password
setup.macaddress = MAC Address
setup.ipv4address = IPv4 Address
setup.concurrentloginlimit = Concurrent Login Limit

username.help = Specifies username of subscriber profile.
password.help = Specifies password of subscriber profile..
macaddress.help =Specifies Calling-Station-Id of subscriber profile. <br><br> A Media Access Control (MAC) address is a unique, twelve-digit, hexadecimal address specific to a network card. <br><br> <b>Sample MAC Addresses:</b> <br><br>Six groups of two hexadecimal digits separated by hyphens (-), like 01-34-67-9A-CD-EF <br><br> Six groups of two hexadecimal digits separated by colons (:), like 01:34:67:9A:CD:EF <br> <br>Three groups of four hexadecimal digits separated by dots (.), like 0134.679A.CDEF
ipv4address.help = Specifies FramedIPv4Address of subscriber profile.
concurrentloginlimit.help = Specifies the maximum number of concurrent sessions that can be allowed to an individual.

#Database configuration parameters 
dbsetup.databaseconnectionparamter.help.decription= database.properties file will be generated with this configuration module
dbsetup.databaseconnectionparamter =  Database Configuration Parameters
dbsetup.connectionurl =  Connection URL
dbsetup.username =  Username
dbsetup.password =  Password
dbsetup.databaseusercreationparameters = Database User Creation Parameters
dbsetup.dbadminusername = DB Admin Username
dbsetup.dbadminuserpassword = DB Admin Password
dbsetup.location = Location(.dbf file)
dbsetup.sqlstatementforcreatinguser = SQL statements
dbsetup.executesqltitle = Executing EliteAAA SM Startup SQL File
dbsetup.executingsqlincreateduser = Database User is created with following credential: 
dbsetup.executedsqltitle = Database Setup is completed
dbsetup.executedsqldescription = Database Setup is completed, kindly press following button to Proceed ahead for EliteAAA SM default setup
dbsetup.createnewuser.help.title = Create New DB User
dbsetup.createnewuser.help.decription = This parameter create new DB user if it is &quot;enabled&quot;. If this parameter is &quot;enabled&quot; then must provide Database administrator username and password
dbsetup.username.help.title = Username(DB user)
dbsetup.username.help.description = &quot;Username&quot; parameter refers to the db username. Following rules for db username: <br><br><ul type=&quot;square&quot;><li>Username must start with alphabet characters only</li><li>After first character allow characters are [a-z, A-Z, 0-9, _]</li><li>Username is case-sensitive</li><li>Username must not be any reserved keyword of oracle</li><li>Username length must be less than or equal to 30 characters</li></ul> 
dbsetup.password.help.title = Password(DB user password)
dbsetup.password.help.description = &quot;Password&quot; parameter refers to the password of db user. Following rules for password: <br><br><ul type=&quot;square&quot;><li>Password must start with alphabet characters only</li><li>After first character allow characters are [a-z, A-Z, 0-9, _]</li><li>Password is case-sensitive</li><li>Password must not be any reserved keyword of oracle</li><li>Password length must be less than or equal to 30 characters</li></ul>
dbsetup.dbadminusername.help.description = &quot;DB Admin Username&quot; parameter refers to the database administrator username
dbsetup.dbadminuserpassword.help.description = &quot;DB Admin Password&quot; parameter refers to the database administrator password
dbsetup.connectionurl.help.description = &quot;Connection URL&quot; parameter refers to the JDBC connection URL 
dbsetup.location.help.description = This parameter will specify the location of your .dbf file. The locations can be specified in any of the below formats:<br><br><b>ORACLE :</b>  &quot;$ORACLE_BASE/oradata/$ORACLE_SID/eliteaaa.dbf&quot; format for the DATAFILE. <br><b>PostgreSQL :</b>  &quot;/opt/postgres/eliteaaa &quot; format for the TABLESPACE. <br><b>RAC :</b>  &quot;+DATA &quot; for the ASM Directory. <br><br> Note: Any appropriate custom name can be mentioned in place of  &quot;eliteaaa&quot; in the above formats

#In-Memory Data Grid
inmemorydatagrid.title  = In-Memory Data Grid
inmemorydatagrid.groupname = Group Name
inmemorydatagrid.grouppassword = Group Password
inmemorydatagrid.groupdescription = Description
inmemorydatagrid.ipaddress = IP Address
inmemorydatagrid.basicdetails = Basic Configuration
inmemorydatagrid.instancename = Instance Name
inmemorydatagrid.groupconfiguration = Group Configuration
inmemorydatagrid.advanced = Advanced Configuration
inmemorydatagrid.properties = Properties
inmemorydatagrid.inmemoryformat = In-Memory Format
inmemorydatagrid.licensekey = License Key
inmemorydatagrid.mancenter = Man Center
inmemorydatagrid.portenabled = Enabled
inmemorydatagrid.mancenterenabled = Enabled
inmemorydatagrid.mancenterurl = Mancenter URL
inmemorydatagrid.ports = Ports
inmemorydatagrid.startportcount = Start Port Count
inmemorydatagrid.outboundports = Outbound Ports
inmemorydatagrid.port = Port
inmemorydatagrid.startport = Start Port
inmemorydatagrid.remove=Remove
inmemorydatagrid.key=Key
inmemorydatagrid.value=Value
inmemorydatagrid.status=In-Memory Data Grid Status
inmemorydatagrid.addgroup=Add Group
inmemorydatagrid.index=In-Memory Data Grid Index
inmemorydatagrid.session.key=Attribute ID
inmemorydatagrid.session.value=Attribute Value

#Script
script.name=This parameter specifies the name of Script Instance
script.scripttype= It is a drop-down box which contains list of Script Type<br><br>\ 1) Driver Script <br>\ 2) Translation Mapping Script <br>\ 3) External Radius Script <br>\ 4) Diameter Router Script
script.description=This parameter specifies the description of to be created Script Instance.

#Database Properties
database.properties.connectionurl = The JDBC URL to the database instance
database.properties.username = The database username
database.properties.password = The database password
database.properties.showsql=Hibernate has build-in a function to enable the logging of all the generated SQL statements to the console. You can change the show sql parameter by using this field. This function is good for basic troubleshooting, and to see what\u2019s Hibernate is doing behind.
database.properties.formatsql=Format the generated SQL statement to make it more readable, but takes up more screen space

#CaseSensitivity
casesensitivity.header = EliteCSM Case Sensitivity Configuration
casesensitivity.subscriber = Case Sensitivity for Subscriber
casesensitivity.policy = Case Sensitivity for Policies

#Concurrency IMDG Handler
radius.concurrency.imdg.handler = This parameter specifies the configured index attribute of Radius IMDG cofiguration. Based on this parameter Radius In-Memory Session Concurrency will be applied.
radius.concurrency.imdg.ruleset = Ruleset

#Correlated Radius
correlated.radius.title = Correlated Radius
correlated.radius.search = SEARCH CORRELATED RADIUS
correlated.radius.create = CREATE CORRELATED RADIUS
correlated.radius.name = Specifies the name of Correlated Radius.
correlated.radius.description = Description
correlated.radius.authesi = Select Auth type ESI
correlated.radius.acctesi = Select Acct type ESI

#Radius Esi Group

radiusesigroup.name= Name of the Radius Esi Group
radiusesigroup.description=Description
radiusesigroup.redundancymode= <br>\ Redundancy defines inclusion of extra components which will be used in case of failure of primary or active component.<br>\
   <br><br>\<b>N+M Redundancy Mode :</b>  This mode defines N number of primary server and M number of secondary or standby server.<br>\
   In case failure from any primary server, request is served by any of standby server as per load factor. \
  All primary server(N) will be configured in primary esi group and standby server(M) will be configured in secondary esi group.<br><br> \
  N+1, N+N or N+M redundancy mode can be achieved.<br>\
  <br><br>\<b>Active-Passive Redundancy Mode :</b> This mode defines each active server has its passive or standby Server.  \
  So, in case of failure of active server, passive server will work in place of it.<br>\ 
radiusesigroup.esitype= ESI type defines which type of ESI has to be configured in primary and seconday esi group.
radiusesigroup.stickysession= It enables stateful behaviour.
radiusesigroup.switchback= It make sense when sticky session is enable. It is the process of restoring operations to a primary server or facility after they have been shifted to a secondary server or facility during failover.
radiusesigroup.esi= Group of Primary and Secondary ESIs.
radiusesigroup.primaryesi= Specify Primary or Active ESI as per ESI Type configuration and its load factor.
radiusesigroup.secondaryesi= Specify Secondary/Standby or Passive ESI as per ESI Type configuration and its load factor.

#Stateful Proxy Sequential Handler
radiusservicepolicy.stateful.proxy.handler = Stateful Proxy(Sequential) Handler
radiusservicepolicy.stateful.proxycommunication.ruleset=Ruleset
radiusservicepolicy.stateful.proxycommunication.servergroup=Server/Group
radiusservicepolicy.stateful.proxycommunication.translationmapping=Translation Mapping
radiusservicepolicy.stateful.proxycommunication.script=Script
radiusservicepolicy.stateful.proxycommunication.acceptontimeout=Accept on Timeout
radiusservicepolicy.stateful.proxycommunication.loadfactor=Load Factor

#Stateful Proxy Broadcst Handler
radiusservicepolicy.stateful.proxycommunication.waitforresponse = Wait For Response