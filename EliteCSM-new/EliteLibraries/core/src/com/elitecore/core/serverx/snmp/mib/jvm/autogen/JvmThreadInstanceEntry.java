package com.elitecore.core.serverx.snmp.mib.jvm.autogen;

//
// Generated by mibgen version 5.1 (03/08/07) when compiling JVM-MANAGEMENT-MIB.
//

// java imports
//
import java.io.Serializable;

// jmx imports
//
import com.sun.management.snmp.SnmpStatusException;

// jdmk imports
//
import com.sun.management.snmp.agent.SnmpMib;

/**
 * The class is used for implementing the "JvmThreadInstanceEntry" group.
 * The group is defined with the following oid: 1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.
 */
public class JvmThreadInstanceEntry implements JvmThreadInstanceEntryMBean, Serializable {

    /**
     * Variable for storing the value of "JvmThreadInstName".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.9".
     *
     * "This thread name - as returned by Thread.getThreadName().
     * 
     * See java.lang.management.ThreadInfo.getThreadName()
     * "
     *
     */
    protected Byte[] JvmThreadInstName = { new Byte("74"), new Byte("68"), new Byte("77"), new Byte("75")};

    /**
     * Variable for storing the value of "JvmThreadInstCpuTimeNs".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.8".
     *
     * "The approximate accumulated CPU time (in nanosecond) for a thread
     * since it has started - or since thread CPU time monitoring was
     * enabled.
     * 
     * If the thread of the specified ID is not alive or does not exist,
     * or the CPU time measurement is disabled or not supported,
     * this object is set to 0.
     * 
     * See java.lang.management.ThreadMXBean.getThreadCpuTime(long),
     * java.lang.management.ThreadMXBean.isThreadCpuTimeSupported(),
     * java.lang.management.ThreadMXBean.isThreadCpuTimeEnabled()
     * "
     *
     */
    protected Long JvmThreadInstCpuTimeNs = new Long(1);

    /**
     * Variable for storing the value of "JvmThreadInstWaitTimeMs".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.7".
     *
     * "The approximate accumulated elapsed time (in millisecond)
     * that a thread has waited on a monitor through a
     * java.lang.Object.wait method since it has started - or since
     * thread contention monitoring wasenabled.
     * 
     * This object is always set to 0 if thread contention monitoring
     * is disabled or not supported.
     * 
     * See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean).
     * getWaitedTime()
     * "
     *
     */
    protected Long JvmThreadInstWaitTimeMs = new Long(1);

    /**
     * Variable for storing the value of "JvmThreadInstWaitCount".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.6".
     *
     * "The total number of times that this thread has waited for
     * notification.
     * 
     * See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean).
     * getWaitedCount()
     * "
     *
     */
    protected Long JvmThreadInstWaitCount = new Long(1);

    /**
     * Variable for storing the value of "JvmThreadInstBlockTimeMs".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.5".
     *
     * "The approximate accumulated elapsed time (in millisecond)
     * that a thread has blocked to enter or re-enter a monitor since
     * it has started - or since thread contention monitoring was
     * enabled.
     * 
     * This object is always set to 0 if thread contention monitoring
     * is disabled or not supported.
     * 
     * See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean).
     * getBlockedTime()
     * "
     *
     */
    protected Long JvmThreadInstBlockTimeMs = new Long(1);

    /**
     * Variable for storing the value of "JvmThreadInstBlockCount".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.4".
     *
     * "The total number of times that this thread has blocked to enter
     * or re-enter a monitor..
     * 
     * See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean).
     * getBlockedCount()
     * "
     *
     */
    protected Long JvmThreadInstBlockCount = new Long(1);

    /**
     * Variable for storing the value of "JvmThreadInstState".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.3".
     *
     * "The state of this thread instance.
     * 
     * See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean).
     * getThreadState()
     * "
     *
     */
    protected Byte[] JvmThreadInstState = { new Byte("74"), new Byte("68"), new Byte("77"), new Byte("75")};

    /**
     * Variable for storing the value of "JvmThreadInstLockOwnerPtr".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.11".
     *
     * "A pointer to the thread which owns the monitor of the
     * object on which this thread instance is blocked.
     * This object will point to jvmThreadInstId of the
     * lock owner thread.
     * 
     * If this thread is not blocked then 0.0 is returned.
     * 
     * See java.lang.management.ThreadInfo.getLockOwnerId()
     * "
     *
     */
    protected String JvmThreadInstLockOwnerPtr = new String("1.3.6.1.4.1.42");

    /**
     * Variable for storing the value of "JvmThreadInstId".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.2".
     *
     * "The thread ID, as returned by Thread.getId().
     * 
     * See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean).
     * getThreadId()
     * "
     *
     */
    protected Long JvmThreadInstId = new Long(1);

    /**
     * Variable for storing the value of "JvmThreadInstLockName".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.10".
     *
     * "The string representation of the monitor lock that this thread
     * is blocked to enter or waiting to be notified through the
     * Object.wait method.
     * 
     * See J2SE 5.0 API Specification,
     * java.lang.management.ThreadInfo.getLockName()
     * for more information on the format of this string.
     * 
     * If this thread is not blocked then a zero-length string is returned.
     * 
     * Note that the SNMP agent may have to truncate the string returned
     * by the underlying API if it does not fit in the JvmJavaObjectNameTC
     * (1023 bytes max).
     * 
     * See java.lang.management.ThreadInfo.getLockName()
     * "
     *
     */
    protected Byte[] JvmThreadInstLockName = { new Byte("74"), new Byte("68"), new Byte("77"), new Byte("75")};

    /**
     * Variable for storing the value of "JvmThreadInstIndex".
     * The variable is identified by: "1.3.6.1.4.1.42.2.145.3.163.1.1.3.10.1.1".
     * In the SNMP MIB, this is defined as a fixed length string of size 8.
     *
     * "An index uniquely identifying a live thread, and directly
     * derived from the value of jvmThreadInstId. The jvmThreadInstId
     * cannot be used directly as index in the table, because integer
     * indexes cannot exceed an unsigned 32 int.
     * 
     * The jvmThreadInstIndex index is an 8 byte octet string as
     * defined by the JvmIndex64TC TEXTUAL-CONVENTION. Its value is
     * directly derived from the value of the corresponding ThreadID
     * returned by jvmThreadInstId.
     * "
     *
     */
    protected Byte[] JvmThreadInstIndex = { new Byte("74"), new Byte("68"), new Byte("77"), new Byte("75")};


    /**
     * Constructor for the "JvmThreadInstanceEntry" group.
     */
    public JvmThreadInstanceEntry(SnmpMib myMib) {
    }

    /**
     * Getter for the "JvmThreadInstName" variable.
     */
    public Byte[] getJvmThreadInstName() throws SnmpStatusException {
        return JvmThreadInstName;
    }

    /**
     * Getter for the "JvmThreadInstCpuTimeNs" variable.
     */
    public Long getJvmThreadInstCpuTimeNs() throws SnmpStatusException {
        return JvmThreadInstCpuTimeNs;
    }

    /**
     * Getter for the "JvmThreadInstWaitTimeMs" variable.
     */
    public Long getJvmThreadInstWaitTimeMs() throws SnmpStatusException {
        return JvmThreadInstWaitTimeMs;
    }

    /**
     * Getter for the "JvmThreadInstWaitCount" variable.
     */
    public Long getJvmThreadInstWaitCount() throws SnmpStatusException {
        return JvmThreadInstWaitCount;
    }

    /**
     * Getter for the "JvmThreadInstBlockTimeMs" variable.
     */
    public Long getJvmThreadInstBlockTimeMs() throws SnmpStatusException {
        return JvmThreadInstBlockTimeMs;
    }

    /**
     * Getter for the "JvmThreadInstBlockCount" variable.
     */
    public Long getJvmThreadInstBlockCount() throws SnmpStatusException {
        return JvmThreadInstBlockCount;
    }

    /**
     * Getter for the "JvmThreadInstState" variable.
     */
    public Byte[] getJvmThreadInstState() throws SnmpStatusException {
        return JvmThreadInstState;
    }

    /**
     * Getter for the "JvmThreadInstLockOwnerPtr" variable.
     */
    public String getJvmThreadInstLockOwnerPtr() throws SnmpStatusException {
        return JvmThreadInstLockOwnerPtr;
    }

    /**
     * Getter for the "JvmThreadInstId" variable.
     */
    public Long getJvmThreadInstId() throws SnmpStatusException {
        return JvmThreadInstId;
    }

    /**
     * Getter for the "JvmThreadInstLockName" variable.
     */
    public Byte[] getJvmThreadInstLockName() throws SnmpStatusException {
        return JvmThreadInstLockName;
    }

    /**
     * Getter for the "JvmThreadInstIndex" variable.
     */
    public Byte[] getJvmThreadInstIndex() throws SnmpStatusException {
        return JvmThreadInstIndex;
    }

}
