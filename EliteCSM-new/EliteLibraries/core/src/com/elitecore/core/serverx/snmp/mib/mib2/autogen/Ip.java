package com.elitecore.core.serverx.snmp.mib.mib2.autogen;

//
// Generated by mibgen version 5.1 (03/08/07) when compiling RFC1213-MIB.
//

// java imports
//
import java.io.Serializable;

import javax.management.MBeanServer;

import com.sun.management.snmp.SnmpStatusException;
import com.sun.management.snmp.agent.SnmpMib;

/**
 * The class is used for implementing the "Ip" group.
 * The group is defined with the following oid: 1.3.6.1.2.1.4.
 */
public class Ip implements IpMBean, Serializable {

    /**
     * Variable for storing the value of "IpFragCreates".
     * The variable is identified by: "1.3.6.1.2.1.4.19".
     *
     * "The number of IP datagram fragments that have
     * been generated as a result of fragmentation at
     * this entity."
     *
     */
    protected Long IpFragCreates = new Long(1);

    /**
     * Variable for storing the value of "IpFragFails".
     * The variable is identified by: "1.3.6.1.2.1.4.18".
     *
     * "The number of IP datagrams that have been
     * discarded because they needed to be fragmented at
     * this entity but could not be, e.g., because their
     * Don't Fragment flag was set."
     *
     */
    protected Long IpFragFails = new Long(1);

    /**
     * Variable for storing the value of "IpFragOKs".
     * The variable is identified by: "1.3.6.1.2.1.4.17".
     *
     * "The number of IP datagrams that have been
     * successfully fragmented at this entity."
     *
     */
    protected Long IpFragOKs = new Long(1);

    /**
     * Variable for storing the value of "IpReasmFails".
     * The variable is identified by: "1.3.6.1.2.1.4.16".
     *
     * "The number of failures detected by the IP re-
     * assembly algorithm (for whatever reason: timed
     * out, errors, etc).  Note that this is not
     * necessarily a count of discarded IP fragments
     * since some algorithms (notably the algorithm in
     * RFC 815) can lose track of the number of fragments
     * by combining them as they are received."
     *
     */
    protected Long IpReasmFails = new Long(1);

    /**
     * Variable for storing the value of "IpReasmOKs".
     * The variable is identified by: "1.3.6.1.2.1.4.15".
     *
     * "The number of IP datagrams successfully re-
     * assembled."
     *
     */
    protected Long IpReasmOKs = new Long(1);

    /**
     * Variable for storing the value of "IpReasmReqds".
     * The variable is identified by: "1.3.6.1.2.1.4.14".
     *
     * "The number of IP fragments received which needed
     * to be reassembled at this entity."
     *
     */
    protected Long IpReasmReqds = new Long(1);

    /**
     * Variable for storing the value of "IpReasmTimeout".
     * The variable is identified by: "1.3.6.1.2.1.4.13".
     *
     * "The maximum number of seconds which received
     * fragments are held while they are awaiting
     * reassembly at this entity."
     *
     */
    protected Integer IpReasmTimeout = new Integer(1);

    /**
     * Variable for storing the value of "IpOutNoRoutes".
     * The variable is identified by: "1.3.6.1.2.1.4.12".
     *
     * "The number of IP datagrams discarded because no
     * route could be found to transmit them to their
     * destination.  Note that this counter includes any
     * packets counted in ipForwDatagrams which meet this
     * `no-route' criterion.  Note that this includes any
     * datagarms which a host cannot route because all of
     * its default gateways are down."
     *
     */
    protected Long IpOutNoRoutes = new Long(1);

    /**
     * Variable for storing the value of "IpOutDiscards".
     * The variable is identified by: "1.3.6.1.2.1.4.11".
     *
     * "The number of output IP datagrams for which no
     * problem was encountered to prevent their
     * transmission to their destination, but which were
     * discarded (e.g., for lack of buffer space).  Note
     * that this counter would include datagrams counted
     * in ipForwDatagrams if any such packets met this
     * (discretionary) discard criterion."
     *
     */
    protected Long IpOutDiscards = new Long(1);

    /**
     * Variable for storing the value of "IpOutRequests".
     * The variable is identified by: "1.3.6.1.2.1.4.10".
     *
     * "The total number of IP datagrams which local IP
     * user-protocols (including ICMP) supplied to IP in
     * requests for transmission.  Note that this counter
     * does not include any datagrams counted in
     * ipForwDatagrams."
     *
     */
    protected Long IpOutRequests = new Long(1);

    /**
     * Variable for storing the value of "IpInDelivers".
     * The variable is identified by: "1.3.6.1.2.1.4.9".
     *
     * "The total number of input datagrams successfully
     * delivered to IP user-protocols (including ICMP)."
     *
     */
    protected Long IpInDelivers = new Long(1);

    /**
     * Variable for storing the value of "IpInDiscards".
     * The variable is identified by: "1.3.6.1.2.1.4.8".
     *
     * "The number of input IP datagrams for which no
     * problems were encountered to prevent their
     * continued processing, but which were discarded
     * (e.g., for lack of buffer space).  Note that this
     * counter does not include any datagrams discarded
     * while awaiting re-assembly."
     *
     */
    protected Long IpInDiscards = new Long(1);

    /**
     * Variable for storing the value of "IpInUnknownProtos".
     * The variable is identified by: "1.3.6.1.2.1.4.7".
     *
     * "The number of locally-addressed datagrams
     * received successfully but discarded because of an
     * unknown or unsupported protocol."
     *
     */
    protected Long IpInUnknownProtos = new Long(1);

    /**
     * Variable for storing the value of "IpForwDatagrams".
     * The variable is identified by: "1.3.6.1.2.1.4.6".
     *
     * "The number of input datagrams for which this
     * entity was not their final IP destination, as a
     * result of which an attempt was made to find a
     * route to forward them to that final destination.
     * In entities which do not act as IP Gateways, this
     * counter will include only those packets which were
     * Source-Routed via this entity, and the Source-
     * Route option processing was successful."
     *
     */
    protected Long IpForwDatagrams = new Long(1);

    /**
     * Variable for storing the value of "IpInAddrErrors".
     * The variable is identified by: "1.3.6.1.2.1.4.5".
     *
     * "The number of input datagrams discarded because
     * the IP address in their IP header's destination
     * field was not a valid address to be received at
     * this entity.  This count includes invalid
     * addresses (e.g., 0.0.0.0) and addresses of
     * unsupported Classes (e.g., Class E).  For entities
     * which are not IP Gateways and therefore do not
     * forward datagrams, this counter includes datagrams
     * discarded because the destination address was not
     * a local address."
     *
     */
    protected Long IpInAddrErrors = new Long(1);

    /**
     * Variable for storing the value of "IpInHdrErrors".
     * The variable is identified by: "1.3.6.1.2.1.4.4".
     *
     * "The number of input datagrams discarded due to
     * errors in their IP headers, including bad
     * checksums, version number mismatch, other format
     * errors, time-to-live exceeded, errors discovered
     * in processing their IP options, etc."
     *
     */
    protected Long IpInHdrErrors = new Long(1);

    /**
     * Variable for storing the value of "IpInReceives".
     * The variable is identified by: "1.3.6.1.2.1.4.3".
     *
     * "The total number of input datagrams received from
     * interfaces, including those received in error."
     *
     */
    protected Long IpInReceives = new Long(1);

    /**
     * Variable for storing the value of "IpDefaultTTL".
     * The variable is identified by: "1.3.6.1.2.1.4.2".
     *
     * "The default value inserted into the Time-To-Live
     * field of the IP header of datagrams originated at
     * this entity, whenever a TTL value is not supplied
     * by the transport layer protocol."
     *
     */
    protected Integer IpDefaultTTL = new Integer(1);

    /**
     * Variable for storing the value of "IpRoutingDiscards".
     * The variable is identified by: "1.3.6.1.2.1.4.23".
     *
     * "The number of routing entries which were chosen
     * to be discarded even though they are valid.  One
     * possible reason for discarding such an entry could
     * be to free-up buffer space for other routing
     * entries."
     *
     */
    protected Long IpRoutingDiscards = new Long(1);

    /**
     * Variable for storing the value of "IpForwarding".
     * The variable is identified by: "1.3.6.1.2.1.4.1".
     *
     * "The indication of whether this entity is acting
     * as an IP gateway in respect to the forwarding of
     * datagrams received by, but not addressed to, this
     * entity.  IP gateways forward datagrams.  IP hosts
     * do not (except those source-routed via the host).
     * 
     * Note that for some managed nodes, this object may
     * take on only a subset of the values possible.
     * Accordingly, it is appropriate for an agent to
     * return a `badValue' response if a management
     * station attempts to change this object to an
     * inappropriate value."
     *
     */
    protected EnumIpForwarding IpForwarding = new EnumIpForwarding();

    /**
     * Variable for storing the value of "IpNetToMediaTable".
     * The variable is identified by: "1.3.6.1.2.1.4.22".
     *
     * "The IP Address Translation table used for mapping
     * from IP addresses to physical addresses."
     *
     */
    protected TableIpNetToMediaTable IpNetToMediaTable;

    /**
     * Variable for storing the value of "IpRouteTable".
     * The variable is identified by: "1.3.6.1.2.1.4.21".
     *
     * "This entity's IP Routing table."
     *
     */
    protected TableIpRouteTable IpRouteTable;

    /**
     * Variable for storing the value of "IpAddrTable".
     * The variable is identified by: "1.3.6.1.2.1.4.20".
     *
     * "The table of addressing information relevant to
     * this entity's IP addresses."
     *
     */
    protected TableIpAddrTable IpAddrTable;


    /**
     * Constructor for the "Ip" group.
     * If the group contains a table, the entries created through an SNMP SET will not be registered in Java DMK.
     */
    public Ip(SnmpMib myMib) {
        IpNetToMediaTable = new TableIpNetToMediaTable (myMib);
        IpRouteTable = new TableIpRouteTable (myMib);
        IpAddrTable = new TableIpAddrTable (myMib);
    }


    /**
     * Constructor for the "Ip" group.
     * If the group contains a table, the entries created through an SNMP SET will be AUTOMATICALLY REGISTERED in Java DMK.
     */
    public Ip(SnmpMib myMib, MBeanServer server) {
        IpNetToMediaTable = new TableIpNetToMediaTable (myMib, server);
        IpRouteTable = new TableIpRouteTable (myMib, server);
        IpAddrTable = new TableIpAddrTable (myMib, server);
    }

    /**
     * Getter for the "IpFragCreates" variable.
     */
    public Long getIpFragCreates() throws SnmpStatusException {
        return IpFragCreates;
    }

    /**
     * Getter for the "IpFragFails" variable.
     */
    public Long getIpFragFails() throws SnmpStatusException {
        return IpFragFails;
    }

    /**
     * Getter for the "IpFragOKs" variable.
     */
    public Long getIpFragOKs() throws SnmpStatusException {
        return IpFragOKs;
    }

    /**
     * Getter for the "IpReasmFails" variable.
     */
    public Long getIpReasmFails() throws SnmpStatusException {
        return IpReasmFails;
    }

    /**
     * Getter for the "IpReasmOKs" variable.
     */
    public Long getIpReasmOKs() throws SnmpStatusException {
        return IpReasmOKs;
    }

    /**
     * Getter for the "IpReasmReqds" variable.
     */
    public Long getIpReasmReqds() throws SnmpStatusException {
        return IpReasmReqds;
    }

    /**
     * Getter for the "IpReasmTimeout" variable.
     */
    public Integer getIpReasmTimeout() throws SnmpStatusException {
        return IpReasmTimeout;
    }

    /**
     * Getter for the "IpOutNoRoutes" variable.
     */
    public Long getIpOutNoRoutes() throws SnmpStatusException {
        return IpOutNoRoutes;
    }

    /**
     * Getter for the "IpOutDiscards" variable.
     */
    public Long getIpOutDiscards() throws SnmpStatusException {
        return IpOutDiscards;
    }

    /**
     * Getter for the "IpOutRequests" variable.
     */
    public Long getIpOutRequests() throws SnmpStatusException {
        return IpOutRequests;
    }

    /**
     * Getter for the "IpInDelivers" variable.
     */
    public Long getIpInDelivers() throws SnmpStatusException {
        return IpInDelivers;
    }

    /**
     * Getter for the "IpInDiscards" variable.
     */
    public Long getIpInDiscards() throws SnmpStatusException {
        return IpInDiscards;
    }

    /**
     * Getter for the "IpInUnknownProtos" variable.
     */
    public Long getIpInUnknownProtos() throws SnmpStatusException {
        return IpInUnknownProtos;
    }

    /**
     * Getter for the "IpForwDatagrams" variable.
     */
    public Long getIpForwDatagrams() throws SnmpStatusException {
        return IpForwDatagrams;
    }

    /**
     * Getter for the "IpInAddrErrors" variable.
     */
    public Long getIpInAddrErrors() throws SnmpStatusException {
        return IpInAddrErrors;
    }

    /**
     * Getter for the "IpInHdrErrors" variable.
     */
    public Long getIpInHdrErrors() throws SnmpStatusException {
        return IpInHdrErrors;
    }

    /**
     * Getter for the "IpInReceives" variable.
     */
    public Long getIpInReceives() throws SnmpStatusException {
        return IpInReceives;
    }

    /**
     * Getter for the "IpDefaultTTL" variable.
     */
    public Integer getIpDefaultTTL() throws SnmpStatusException {
        return IpDefaultTTL;
    }

    /**
     * Setter for the "IpDefaultTTL" variable.
     */
    public void setIpDefaultTTL(Integer x) throws SnmpStatusException {
        IpDefaultTTL = x;
    }

    /**
     * Checker for the "IpDefaultTTL" variable.
     */
    public void checkIpDefaultTTL(Integer x) throws SnmpStatusException {
        //
        // Add your own checking policy.
        //
    }

    /**
     * Getter for the "IpRoutingDiscards" variable.
     */
    public Long getIpRoutingDiscards() throws SnmpStatusException {
        return IpRoutingDiscards;
    }

    /**
     * Getter for the "IpForwarding" variable.
     */
    public EnumIpForwarding getIpForwarding() throws SnmpStatusException {
        return IpForwarding;
    }

    /**
     * Setter for the "IpForwarding" variable.
     */
    public void setIpForwarding(EnumIpForwarding x) throws SnmpStatusException {
        IpForwarding = x;
    }

    /**
     * Checker for the "IpForwarding" variable.
     */
    public void checkIpForwarding(EnumIpForwarding x) throws SnmpStatusException {
        //
        // Add your own checking policy.
        //
    }

    /**
     * Access the "IpNetToMediaTable" variable.
     */
    public TableIpNetToMediaTable accessIpNetToMediaTable() throws SnmpStatusException {
        return IpNetToMediaTable;
    }

    /**
     * Access the "IpNetToMediaTable" variable as a bean indexed property.
     */
    public IpNetToMediaEntryMBean[] getIpNetToMediaTable() throws SnmpStatusException {
        return IpNetToMediaTable.getEntries();
    }

    /**
     * Access the "IpRouteTable" variable.
     */
    public TableIpRouteTable accessIpRouteTable() throws SnmpStatusException {
        return IpRouteTable;
    }

    /**
     * Access the "IpRouteTable" variable as a bean indexed property.
     */
    public IpRouteEntryMBean[] getIpRouteTable() throws SnmpStatusException {
        return IpRouteTable.getEntries();
    }

    /**
     * Access the "IpAddrTable" variable.
     */
    public TableIpAddrTable accessIpAddrTable() throws SnmpStatusException {
        return IpAddrTable;
    }

    /**
     * Access the "IpAddrTable" variable as a bean indexed property.
     */
    public IpAddrEntryMBean[] getIpAddrTable() throws SnmpStatusException {
        return IpAddrTable.getEntries();
    }

}
