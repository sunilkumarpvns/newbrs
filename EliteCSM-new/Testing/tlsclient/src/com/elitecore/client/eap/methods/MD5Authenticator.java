package com.elitecore.client.eap.methods;

import java.security.MessageDigest;
import java.util.ArrayList;
import java.util.List;

import javax.naming.AuthenticationException;

import com.elitecore.client.configuration.EapConfiguration;
import com.elitecore.client.eap.EapMethodAuthenticator;
import com.elitecore.client.util.constants.CommunicationStates;
import com.elitecore.commons.logging.LogManager;
import com.elitecore.coreeap.packet.InvalidEAPTypeException;
import com.elitecore.coreeap.packet.types.EAPType;
import com.elitecore.coreeap.packet.types.md5.MD5ChallengeEAPType;
import com.elitecore.coreeap.util.Utility;
import com.elitecore.coreeap.util.constants.tls.HashAlgorithm;

/**
 *  Handles EAP-MD5Challenge inner method for outer EAP-PEAP.
 *  Generates the response according to challenge generated from server.
 *  
 * @author Kuldeep Panchal
 * @author Malav Desai
 *
 */
public class MD5Authenticator implements EapMethodAuthenticator{
	
	private String MODULE = "MD5_Authenticator";
	private CommunicationStates state;
	private final String innerIdentity;
	private final String innerPasswd;
	private EapConfiguration configuration;
	private List<EAPType> eapTypes;
	
	public MD5Authenticator(EapConfiguration configuration) {
		this.configuration = configuration;
		state = CommunicationStates.CONTINUE;
		innerIdentity = configuration.getPeap().getInnerIdentity();
		innerPasswd = configuration.getPeap().getInnerPasswd();
		eapTypes = new ArrayList<EAPType>(3);
	}

	@Override
	public void reset() {
		state = CommunicationStates.CONTINUE;
		eapTypes = new ArrayList<EAPType>(3);
	}

	@Override
	public CommunicationStates process(byte[] inTlsData) throws AuthenticationException {
		LogManager.getLogger().info(MODULE, "Current State: " + state);
		switch (state) {
		case CONTINUE:
			actionOnRecivedData(inTlsData);
			break;
		case COMPLETED_PROCESSING:
			break;

		default:
			LogManager.getLogger().error(MODULE, "Not in proper state. Something in fishy");
			throw new AuthenticationException(MODULE + " not in proper state");
		}
		return state;
	}
	
	/**
	 *  Generates the Response for the MD5-Challenge using the challenge generated by the server.
	 * 
	 * @param inTlsData
	 * @throws AuthenticationException 
	 */
	private void actionOnRecivedData(byte[] inTlsData) throws AuthenticationException {

		try {
			MD5ChallengeEAPType eapType = new MD5ChallengeEAPType(inTlsData);

			//TODO check eap-response packet from "The EAP MD5-Tunneled Authentication Protocol(EAP-MD5-Tunneled)"
			MD5ChallengeEAPType resp = new MD5ChallengeEAPType();
			resp.setName(eapType.getName());
			resp.setValue(generateChallenge(eapType));
			eapTypes.add(resp);
		} catch (InvalidEAPTypeException e) {
			LogManager.getLogger().error(MODULE, "EAPPacket not generated. Reason : " + e.getMessage());
			throw new AuthenticationException("Improper packet generated");
		}
	}
	
	private byte[] generateChallenge(MD5ChallengeEAPType eapType){
		MessageDigest md = Utility.getMessageDigest(HashAlgorithm.MD5.name());
		md.update((byte) configuration.getIdentifier());
		md.update(innerPasswd.getBytes());
		md.update(eapType.getValue());
		return md.digest();
	}

	@Override
	public byte[] getOutData() {
		return eapTypes.remove(0).toBytes();
	}
}